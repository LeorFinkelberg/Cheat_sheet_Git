\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Практика использования и наиболее полезные конструкции\\системы контроля версий  \texttt{Git}}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents


\section{Термины и определения}

\noindent\texttt{HEAD} -- специальный \textit{указатель} на текущую \emph{локальную ветку}, которая в свою очередь ссылается на последнее зафиксированное состояние, т.е. на \emph{последний} сделанный в ней \emph{коммит}. 


\section{Фундаментальные концепции}

\subsection{Слияние}

При \emph{слиянии} веток снчала нужно перейти в ту ветку, в которую требуется слить данные, а затем применить команду \texttt{git merge}, т.е.

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout master
git merge server
\end{lstlisting}

\subsection{Перемещение}

При \emph{перемещении}\footnote{Т.е. чтобы повторить изменения из одной ветки в другой} данных из одной ветки в другую следует сначала перейти в ту ветку, из которой требуется перенести данные, а затем воспользоваться \texttt{git rebase}, т.е.

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout experiment
git rebase master
\end{lstlisting}

\subsection{Общая схема работы в небольшой команде}

Общая схема работы в небольшой команде:
\begin{itemize}
	\item Некоторое время вы работаете в тематической ветке (например, \texttt{issue54}), и когда приходит время, сливаете результаты своего труда в ветку \texttt{master}
	
\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout master
git merge issue54
\end{lstlisting}
	
	\item Решив, что пришло время поделиться своими наработками с коллегами, вы скачиваете данные с сервера (\texttt{git fetch origin}), и если там появились изменения, сливаете к себе ветку \texttt{origin/master}, т.е. \texttt{git merge origin/master},
	
	\item После чего содержимое ветки \texttt{master} можно отправить на сервер \texttt{git push origin master}.
\end{itemize}

\subsection{Команда \texttt{git reset}}

В случае конструкции \texttt{git reset HEAD\~} команда \texttt{git reset} на \emph{первом шаге} переместит текущую локальную ветку на один элемент назад, то есть в данном случае ветка \texttt{master} будет указывать на предпоследний коммит. И в случае команды \verb|git reset --soft| этот же шаг окажется последним. Другими словами, команда \verb|git reset --soft HEAD~| просто перемещает ветку на один коммит назад (\emph{отменяет последний коммит}, т.е. отменяет действие команды \texttt{git commit}), не затрагивая ни \emph{область индексирования}, ни \emph{рабочую папку}. Если сейчас посмотреть статус \texttt{git status}, то файлы, которые вошли в отмененный коммит, будут проиндексированны и готовы к фиксации. Этим можно воспользоваться например так: создадим новый файл, проиндексируем его (\texttt{git add}), а затем все зафиксируем (\texttt{git commit}) вместе со старыми проиндексированными файлами.

Следующим действием команды \texttt{git reset} станет \emph{обновление области индексирования} путем добавления туда содержимого снимка, на который нацелен указатель \texttt{HEAD}. Если команда вызывается без аргументов (т.е. \texttt{git reset HEAD\~}), то на этом шаге работа команды заканчивается. Команда \texttt{git reset HEAD\~} не только отменяет последний коммит, но и убирает из области индексирования все находившиеся там файлы. То есть этот вариант команды \texttt{git reset} отменяет как \texttt{git commit}, так и \texttt{git add}.

Третьим действием команды \texttt{git reset} станет приведение рабочей папки к виду, который имеет область индексирования. До этой стадии команда работает при наличии параметра \verb|--hard|. То есть \verb|git reset --hard HEAD~| убирает последний коммит, результаты работы команд \texttt{git add} и \texttt{git commit} и все наработки из рабочей папки. Важно понимать, что только параметр \verb|--hard| делает команду \texttt{git reset} по настоящему опасной. Это один из немногочисленных случаев, когда \texttt{Git} реально удаляет данные. 

\paragraph{Заключение} команда \texttt{git reset} в определенном порядке переписывает три дерева, останавливаясь в указанном месте:
\begin{itemize}
	\item перемещает ветку, на которую нацелен указатель \texttt{HEAD} (и останавливается при наличии \verb|--soft|),
	
	\item приводит вид области индексирования в соответствие с данными, на которые нацелен указатель \texttt{HEAD} (и без параметра \verb|--hard| на этом останавливается),
	
	\item приводит вид рабочей папки в соответствие с видом области индексирования.
\end{itemize}

Кроме того команде \texttt{git reset} можно передавать путь. В этом случае команда пропускает первый этап и ограничивает свою работу определенным файлом или набором файлов.

Такое поведение имеет смысл, ведь указатель \texttt{HEAD} не может быть нацелен частично на один коммит, а частично на другой. А вот частичное обновление области индексирования и рабочей папки -- вполне реальная операция, поэтому команда \texttt{git reset} сразу переходит к этапам 2 и 3.

Команда \texttt{git reset file\_name} обратна по смыслу команде \texttt{git add file\_name}, т.е. \texttt{git add} индексирует файл, а \texttt{git reset} отменяет индексирование файла.

Можно явно указать коммит, из которого следует брать версию файла, например, \texttt{git reset eb43bf}.



\section{Конструкции \texttt{Git}}

\subsection{Настройка Git}

Задать глобальные настройки можно следующим образом

\begin{lstlisting}[
language = cmd,
numbers = none
]
git config --global user.name "[name]"
git config --global user.email "[email address]"
\end{lstlisting}

Для того чтобы \texttt{Git} при слияниях, которые сопроваждаются разрешением конфликтов, использовал кэш следует воспользоваться конструкцией

\begin{lstlisting}[
language = cmd,
numbers = none
]
git config --global rerere.enabled true
\end{lstlisting}

\subsection{Информация о снимке}

Вывести информацию о текущем снимке \texttt{HEAD}
\begin{lstlisting}[
language = cmd,
numbers = none
]
git cat-file -p HEAD
\end{lstlisting}

Вывести список файлов, попавших в родительский снимок \texttt{HEAD}
\begin{lstlisting}[
language = cmd,
numbers = none
]
git ls-tree -r HEAD~
\end{lstlisting}

Вывести текущее содержимое индекса (снимок, предложенный для следующего коммита)
\begin{lstlisting}[
language = cmd,
numbers = none
]
git ls-files
\end{lstlisting}


\subsection{Добавление файлов в область индексирования}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git add file_name.py
git add .
\end{lstlisting}


\subsection{Фиксация изменений}

Зафиксировать измененное состояние

\begin{lstlisting}[
language = cmd,
numbers = none
]
git commit -m 'Initial commit'
\end{lstlisting}

Зафиксировать измененное состояние, пропустив область индексирования

\begin{lstlisting}[
language = cmd,
numbers = none
]
git commit -a -m 'Some comment'
\end{lstlisting}

Исправить комментарий последнего коммита. Комментарий последнего коммита будет перезаписан

\begin{lstlisting}[
language = cmd,
numbers = none
]
git commit -m 'New some comment' --amend
\end{lstlisting}

Чтобы исправить комментарий коммита (или комментарии нескольких коммитов), созданного некоторое время назад (т.е. речь идет не о последнем коммите) следует перейти в интерактивный режим с помощью команды

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase -i HEAD~15
\end{lstlisting}
затем в открывшемся файле заменить <<pick>> на <<reword>> (изменить комментарий коммита), сохранить файл и закрыть его.

Далее для каждого коммита (помеченного <<reword>>) можно будет исправить комменатрий. После следует сохранить файл и закрыть его. В завершении требуется залить данные на удаленный сервер в принудительном режиме, т.е.
\begin{lstlisting}[
language = cmd,
numbers = none
]
git push --force
\end{lstlisting}


\subsection{Удаление файлов}

Удалить файл из \emph{области индексирования} и заодно удалить указанный файл из рабочей папки. Чтобы система \texttt{Git} перестала работать с файлом, его нужно удалить из числа отслеживаемых (точнее, убрать из области индексирования) и зафиксировать данное изменение 

\begin{lstlisting}[
language = cmd,
numbers = none
]
$ git rm file_name.py
\end{lstlisting}


Удалить файл из области индексирования\footnote{\texttt{Git} перестает следить за файлом, т.е. он становится \emph{неотслеживаемым}!}, но оставить его в рабочей папке. Данная команда в отличие от \texttt{git reset HEAD file\_name.py} может использоваться как до первой фиксации (\texttt{git commit}), так и после

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rm --cached file_name.py
\end{lstlisting}


Удалить все файлы с расширением \texttt{.log}\footnote{Символ \texttt{*} экранируется} из директории \texttt{log/}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rm log/\*.log
\end{lstlisting}


\subsection{Переименование файлов}

Переименовать файл

\begin{lstlisting}[
language = cmd,
numbers = none
]
git mv old_file_name new_file_name
\end{lstlisting}


Переименовать файл с использованием \texttt{\{..\}}
\begin{lstlisting}[
language = cmd,
numbers = none
]
git mv test_file{,_new}.py
\end{lstlisting}


\subsection{Просмотр истории коммитов}

Вывести историю коммитов

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log
\end{lstlisting}


Вывести историю коммитов, ограничившись последними двумя, с указанием разницы, которую внес каждый коммит

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log -p -2
\end{lstlisting}

Вывести историю коммитов с краткой статистикой

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --stat
\end{lstlisting}

Вывести историю коммитов с указанием сокращенного варианта хеш-кода коммита и комментария

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --pretty=format:'%h %s'
\end{lstlisting}


Вывести историю коммитов за последние 2 недели

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --since=2.week
\end{lstlisting}


Вывести историю коммитов с захватом интересующего слова в коммите, ограничившись последними двумя

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --grep='key word' -2
\end{lstlisting}


Вывести историю коммитов, которые попали в заданный временной диапазон

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --since='2020-03-01 10:00' --before ='2020-03-01 11:00'
\end{lstlisting}


Вывести историю коммитов с указанием сокращенного хеш-кода коммита, тегов, текущей векти и собственно коммита

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --oneline
\end{lstlisting}


Вывести историю коммитов, показывая места расположения указателей и точек расхождения

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --oneline --decorate --all --graph
\end{lstlisting}

Отобразить только те не подвергавшиеся слиянию коммиты из ветки \texttt{origin/master}, которых нет в ветке \texttt{issue54}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --no-merges issue54..origin/master
\end{lstlisting}

Вывести информацию о том чем ветка \texttt{origin/master} будет отличаться от ветки \texttt{master}\footnote{Этот прием бывает полезен тогда, когда требуется предварительно посмотреть данные, которые будут слиты в ветку} (каких коммитов нет в ветке \texttt{origin/master})

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log origin/master..master -p
\end{lstlisting}

Еще данный синтаксис часто используется для просмотра информации, которую вы собираетесь отправить на удаленный сервер

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log origin/master..HEAD
\end{lstlisting}
или короткий вариант
\begin{lstlisting}[
language = cmd,
numbers = none
]
git log origin/master..
\end{lstlisting}
так как \texttt{Git} вместо пропущенного фрагмента подставляет \texttt{HEAD}.

Вывести информацию из журнала ссылок\footnote{Этот способ работает только для данных, которые все еще находятся в журнале ссылок, поэтому его невозможно исопльзовать для просмотра коммитов, возраст которых превышает несколько месяцев}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log -g master
\end{lstlisting}


\subsection{Отмена индексирования}

Отменить индексирование файла (файл удаляется из области индексирования). Данная команда может применяться только после первой фиксации (\texttt{git commit})

\begin{lstlisting}[
language = cmd,
numbers = none
]
git reset HEAD file_name.py
\end{lstlisting}


\subsection{Работа с удаленными репозиториями}

Добавить удаленный репозиторий под коротким именем \texttt{pb}. Теперь вместо полного URL можно использовать имя \texttt{pb}

\begin{lstlisting}[
numbers = none
]
git remote add pb https://github.com/paulboone/ticgit
\end{lstlisting}


\emph{Извлечь данные} из удаленного репозитория. Эта команда связывается с удаленным проектом и извлекает оттуда все пока отсутствующие в локальном репозитории данные. Она \emph{\color{red}не выполняет} автоматического слияния с ветками, и вообще никак не затрагивает эти ветки

\begin{lstlisting}[
language = cmd,
numbers = none
]
git fetch origin
\end{lstlisting}


Отправить данные локальной ветки \texttt{master} на удаленный репозиторий \texttt{origin}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin master
\end{lstlisting}


Передать данные от локальной ветки \texttt{serverfix} в ветку \texttt{awesomebranch} на удаленном репозитории

\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin serverfix:awesomebranch
\end{lstlisting}

Вывести информацию о конкретном удаленном репозитории \texttt{origin}

\begin{lstlisting}[
numbers = none
]
git remote show origin
\end{lstlisting}


Изменить имя удаленного репозитория с \texttt{pb} на \texttt{paul}. Теперь к ветке \texttt{pb/master} нужно будет обращаться по имени \texttt{paul/master}

\begin{lstlisting}[
numbers = none
]
git remote rename pb paul
\end{lstlisting}


Удалить ссылку на удаленный репозиторий

\begin{lstlisting}[
numbers = none
]
git remote rm paul
\end{lstlisting}


\subsection{Работа с тегами}

Вывести список доступных тегов

\begin{lstlisting}[
language = cmd,
numbers = none
]
git tag
\end{lstlisting}


Вывести список тегов, отвечающих поисковому  шаблону

\begin{lstlisting}[
language = cmd,
numbers = none
]
git tag -l 'v1.8.*'
git tag -l 'v0.2*.*'
\end{lstlisting}


Создать тег с комментарием. Тег привязывается к последнему коммиту

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log -a v1.4 -m 'My version 1.4'
\end{lstlisting}

Вывести информацию по тегу

\begin{lstlisting}[
language = cmd,
numbers = none
]
git show v1.4
\end{lstlisting}


Создать легковесный тег (просто не указываются \texttt{-a}, \texttt{-s}, \texttt{-m})

\begin{lstlisting}[
language = cmd,
numbers = none
]
git tag v1.4-lw
\end{lstlisting}


Отправить все теги на удаленный репозиторий. По умолчанию команда \texttt{git push} не отправляет теги на удаленный репозиторий

\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin --tags
\end{lstlisting}


\subsection{Работа с ветками}

Вывести список существующих веток

\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch
\end{lstlisting}


Создать новую ветку

\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch testing
\end{lstlisting}

Переключиться на новую ветку

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout testing
\end{lstlisting}

Создать новую ветку и тут же переключитсья на нее

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout -b iss53
\end{lstlisting}


Внедрить внесенные изменения в готовый код

\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge hotfix
\end{lstlisting}

Удалить ветку 

\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch -d hotfix
\end{lstlisting}

Вывести ветки, НЕ объединенные с текущей веткой

\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch --no-marged
\end{lstlisting}


Создать \emph{локальную копию ветки} \texttt{serverfix} на основе \emph{удаленной ветки} \texttt{origin/serverfix}. В результате будет получена локальная ветка, которая начинается там же, где и ветка \texttt{origin/serverfix}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout -b serverfix origin/serverfix
\end{lstlisting}

\noindent или альтернативный вариант

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout --track origin/serverfix
\end{lstlisting}

Создать локальную копию ветки с именем \texttt{sf} на основе удаленной ветки \texttt{origin/serverfix}. Теперь локальная ветка \texttt{sf} поддерживает автоматический обмен данными с удаленной веткой \texttt{origin/serverfix}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout -b sf origin/serverfix
\end{lstlisting}


Вывести только те коммиты, которых нет в первой ветке (ветка \texttt{master})

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log master..contrib
\end{lstlisting}
или так
\begin{lstlisting}[
language = cmd,
numbers = none
]
git log contrib --not master
\end{lstlisting}
или так
\begin{lstlisting}[
language = cmd,
numbers = none
]
git log ^master contrib
\end{lstlisting}


Вывести только те наработки из \emph{тематической ветки}, которые появились там после расхождения с веткой \texttt{master}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git diff master...contrib
\end{lstlisting}

Вывести изменения, которые присутствуют только в ветке \texttt{master}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git diff origin/master..master
\end{lstlisting}

Для обращения к существующей ветке можно использовать краткую форму \texttt{@\{u\}}. К примеру, если мы следим из ветки \texttt{master} за веткой \texttt{origin/master}, то для краткости можно писать так

\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge @{u}
\end{lstlisting}
вместо
\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge origin/master
\end{lstlisting}

Вывести список веток \emph{наблюдения}. Все цифры представляют собой показатели, зафиксированные в момент последнего скачивания данных с каждого сервера. Данная команда не обращается к серверам, а просто сообщает локальные данные из кэша. Для получения актуальной информации о количестве новых коммитов на локальных и удаленных ветках следует извлечь данные со всех удаленных серверов и только затем воспользоваться этой командой, т.е.
\begin{lstlisting}[
language = cmd,
numbers = none
]
git fetch --all
git branch -vv
 iss53 7e424c3 [origin/iss53: ahead 2] forgot the brackets
 master 1ae2a45 [origin/master] deploying index fix
 serverfix 5ea463a [teamone/server-fix-good: ahead 3, behind] this should do it
 ...
\end{lstlisting} 


\subsection{Отправка данных на удаленный репозиторий}

Для того чтобы отправить данные из локального репозитория на удаленный следует использовать конструкцию

\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin master
\end{lstlisting}

\noindent но предварительно необходимо слить данные из удаленного репозитория с помощью команды

\begin{lstlisting}[
language = cmd,
numbers = none
]
git pull origin master --allow-unrelated-histories
\end{lstlisting}


\subsection{Перемещение данных}

Изменения, зафиксированные в одной ветке, повторить в другой ветке (в \texttt{Git} это называется \emph{перемещением}). Например, чтобы повторить изменения из ветки \texttt{experiment} в ветке \texttt{master}, следует сначала перейти в ту ветку, из которой требуется перенести изменения (ветка \texttt{experiment}), а затем воспользоваться командой \texttt{git rebase}\footnote{Работает это следующим образом: ищется общий предок двух веток (текущей ветки и ветки, в которую выполняется перемещение), вычисляется разница, вносимая каждым коммитом текущей ветки, и сохраняется во временных файлах. После этого текущая ветка сопоставляется тому же коммиту, что и ветка, в которую осуществляется перемещение, и одно за другим происходят все изменения}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout experiment
git rebase master
\end{lstlisting}


Внести изменения клиентской части (ветка \texttt{client}) в окончательную версию кода (ветка \texttt{master}), оставив изменения серверной части (ветка \texttt{server}) для дальнейшего тестирования. Другими словами, взять изменения клиентской части, не связанные с изменениями на серверной стороне, и воспроизвести их в ветке \texttt{master} можно следующим образом\footnote{По сути, команда приказывает <<перейти в ветку \texttt{client}, найти исправления от общего предка веток \texttt{client} и \texttt{server} и повторить их в ветке \texttt{master}>>}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase --onto master server client
\end{lstlisting}

Переместить изменения из ветки \texttt{server} в ветку \texttt{master}, вне зависимости от того, в какой ветке вы находитесь, позволяет команда \texttt{git rebase [main\_branch] [topic\_branch]}. Эта команда переключает на тематическую ветку (в данном случае -- на ветку \texttt{server}) и воспроизводит ее содержимое в основной ветке (\texttt{master})

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase master server
\end{lstlisting}

\remark{%
    При перемещении изменений из одной ветки в другую, нужно перейти на ту ветку, \emph{из которой} планируется переместить изменения
}

\subsection{Перемещение отдельного коммита}

Взять представленные в коммите изменения и попытаться применить их в текущей ветке. Команда извлечет изменения, появившиеся в коммите, но при этом измениться контрольная сумма SHA-1 коммита, так как у него другая дата применения

\begin{lstlisting}[
language = cmd,
numbers = none
]
git cherry-pick e43a6fd3e9488...
\end{lstlisting}


\subsection{Удаление коммитов}

Для того чтобы удалить послдений коммит следует сначала удалить коммит в локальном репозитории

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase -i HEAD~2
\end{lstlisting}
а затем отправить данные в форсированном режиме на удаленный репоизторий

\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin +master --force
\end{lstlisting}


\remark{%
После удаления коммита или после изменения комментария коммита обязательно нужно <<залить>> обновления на удаленный сервер с помощью \lstinline{git push origin master --force}
}


\subsection{Просмотр информации по коммитам}

Если требуется вывести информацию по коммиту (например, требуется выяснить что было удалено/добавлено в этот коммит), то можно обратиться к коммиту через его хеш-код

\begin{lstlisting}[
language = cmd,
numbers = none
]
git show 06e6bbc
\end{lstlisting}

Информацию по последнему коммиту можно посмотреть следующим образом

\begin{lstlisting}[
language = cmd,
numbers = none
]
git show master
\end{lstlisting}

\subsection{Ссылки на предков}

Для просмотра \emph{предыдущего коммита} достаточно написать \texttt{HEAD\^}, что означает <<родитель HEAD>>

\begin{lstlisting}[
language = cmd,
numbers = none
]
git show HEAD^
\end{lstlisting}


Другое распространенное обозначение \emph{предка} -- символ \lstinline{~}. Он также соответствует \emph{ссылке на первого родителя}, поэтому записи \lstinline{HEAD^} и \lstinline{HEAD~} эквивалентны. А вот если указать номер после символа \lstinline{~}, то проявятся различия между \lstinline{~} и \lstinline{^}.

Например, запись \lstinline{HEAD~2} означает <<первый предок первого предка>>, при этом происходит переход от заданного предка вглубь указанное число раз, т.е. \lstinline{HEAD~3} укажет на четвертый\footnote{Так как отсчет ведется, начиная со второго коммита от конца ветки} от конца ветки коммит.

После символа \lstinline{^} можно указать число: например, запись \lstinline{d921970^2} означает <<второй предок коммита d921970>>. Этот синтаксис применяется \underline{только} в случае \emph{коммитов слияния}, у которых существует несколько предков. \emph{Первый родитель} -- это ветка, на которой вы находились в момент слияния, а \emph{второй родитель} -- коммит на ветке, которая подверглась слиянию

\begin{lstlisting}[
language = cmd,
numbers = none
]
git show d921970^2
\end{lstlisting}

Указанные обозначения можно комбинировать. К примеру, второго родителя четвертого от конца ветки коммита (при условии, что это коммит слияния) можно получить, написав \lstinline{HEAD~3^2}.

\subsection{Диапазоны коммитов}

Вывести все коммиты, достижимые по ссылке \texttt{refA} или \texttt{refB}, но не достижимые по ссылке \texttt{refC}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log refA refB ^refC
git log refA refB --not refC
\end{lstlisting}

Вывести только те коммиты, которые есть либо в ветке \texttt{master}, либо в ветке \texttt{experiment}, но не в обеих ветках одновременно

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log master...experiment
\end{lstlisting}

С этой командой часто используют параметр \lstinline{--left-right}, позволяющий посмотреть, с какой стороны диапазона находится каждый коммит

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --left-right master...experiment
\end{lstlisting}

\subsection{Скрытие и очистка}

Часто во время работы над проектом, все еще находится в беспорядочном состоянии, возникает необходимость перейти в другую ветку и поработать над другим аспектом. Проблема в том, что фиксировать работу, сделанную наполовину, чтобы позже к ней вернуться вы не хотите. В такой ситуации на помощь приходит команда \texttt{git stash}.

Если, к примеру, вы отредактируете два файла и только один из них проиндексируете без фиксации результатов своей работы, то с помощью команды
\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash save
\end{lstlisting}
можно будет перейти на другую ветку, скрыв наработки в буфере.

\remark{%
По умолчанию команда \texttt{git stash} сохраняет только файлы из \emph{области индексирования}
}

Теперь можно легко менять ветки и работать над другими фрагментами проекта -- все изменения хранятся в стеке. Увидеть содержимое позволяет команда

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash list
\end{lstlisting}

Вернуть спрятанные в буфер изменения в рабочее состояние можно командой

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash apply
\end{lstlisting}

Если требуется вернуться к работе над версией, сохраненной в буфере ранее, следует указать ее номер

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash apply stash@{2}
\end{lstlisting}

\remark{%
Вообще говоря, нет необходимости возвращать содерижмое буфера в чистый рабочий каталог и в ту же ветку, из которой они были сохранены. Можно скрыть изменения одной ветки, перейти в другую и попытаться вставить изменнное состояние туда
}

После извлечения информации из буфера файлы, которые до помещения в буфер были проиндексированы, автоматически в это состояние не вернуться. Чтобы сразу вернуть данные из буфера в исходное состояние, нужно написать

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash apply --index
\end{lstlisting}

При этом команда \texttt{apply} только возвращает данные в ветку, но из стека они никуда не деваются. Убрать их из стека позволяет команда \texttt{git stash drop} с именем удаляемого файла

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash drop stash@{0}
\end{lstlisting}


Врочем, существует также команда
\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash pop
\end{lstlisting}
которая возвращает сохраненную в буфере информацию в ветку и немедленно удаляет ее из буфера.

\subsubsection{Более сложные варианты скрытия}

Чтобы не скрывать данные, которые были проиндексированы командой \texttt{git add}, следует написать

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash save --keep-index
\end{lstlisting}

Команда \texttt{git stash} по умолчанию сохраняет только данные из области индексирования, но параметр \lstinline{--include-untracked} или \lstinline{-u} заставляет систему \texttt{Git} сохранять также все \emph{неотслеживаемые файлы}.

Для того чтобы в интерактивном режиме указать \texttt{Git} какие файлы нужно скрыть, а какие нет, следует воспользоваться конструкцией

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash save --patch
\end{lstlisting}


\subsection{Отмена скрытых изменений}

Может возникнуть ситуация, когда после возвращения изменений из буфера вы выполняете некую работу, а затем хотите отменить изменеия, внесенные из буфера. Сделать это можно следующим образом: сначала нужно извлечь связанные с буфером исправления, а затем применить их в реверсивном виде

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash show -p stash@{0} | git apply -R
\end{lstlisting}

\remark{%
Если скрыть некие наработки, оставить их на некоторое время в буфере, а тем временем продолжить работу в ветке, из которой была скрыта информация, в итоге можно столкнуться с ситуацией, когда просто взять и вернуть данные из буфера не удастся.

Намного проще протестировать скрытые изменения командой \texttt{git stash branch branch\_name}. Она создает новую ветку, переходит к коммиту, в котором вы находились на момент скрытия работы, копирует в новую ветку содержимое буфера и очищает его, если изменения прошли успешно. Это удобный спсоб легко восстановить скрытые изменения и продолжить работу с ними в новой ветке
}



\subsection{Принудительно перезаписать локальные файлы}

Если требуется локальные файлы перезаписать файлами с удаленного сервера, то алгоритм следующий

\begin{lstlisting}[
language = cmd,
numbers = none
]
git fetch --all
get reset --hard origin/master
\end{lstlisting}

Команда \lstinline{git fetch --all} скачивает отсутствующие файлы с удаленного репозитория без попытки слить или переместить данные, а \lstinline{git reset --hard origin/master} <<сбрасывает>> ветку \texttt{master}. Опция \lstinline{--hard} изменяет все файлы в рабочем дереве таким образом, чтобы они совпадали с файлами из \texttt{master/origin}.

\subsection{Очистка рабочей папки}

В некоторых ситуациях лучше не скрывать результаты своего труда или файлы, а избавиться от них. Это можно сделать командой \texttt{git clean}. Удаление требуется, чтобы убрать мусор, сгенерированный путем слияния или внешними инструментами, или чтобы избавиться от артефактов сборки в процессе ее очистки.

С этой командой надо быть крайне аккуратным, так как она предназначена для удаления неотслеживаемых файлов из рабочей папки. Даже если вы передумаете, восстановить содержимое таких файлов, как правило, будет невозможно. Безопаснее воспользоваться командой \lstinline{git stash --all}, скрывающей из папки все содержимое, но с последующим его сохранением в буфере.

Предположим, вы все-таки хотите удалить командой \lstinline{git clean} мусорные файлы или очистить вышу рабочую папку. Для удаления из этой папки всех \emph{неотслеживаемых} файлов используйте команду \lstinline{git clean -f -d}\footnote{Параметр \lstinline{-f} означает принудительное удаление}, которая полностью очищает папку, убирая не только файлы, но и вложенные папки.

Бывает полезно перед действительным удалением посмотреть на результа имитационного удаления. Сделать это можно, добавив ключ \lstinline{-n}, т.е.


\begin{lstlisting}[
language = cmd,
numbers = none
]
git clean -d -n
\end{lstlisting}

По умолчанию команда \lstinline{git clean} удаляет только \emph{неотслеживаемые} файлы, не добавленные в список игнорированных, т.е. любой файл, имя которого совпадает с шаблоном в файле \texttt{.gitignore}, сохраниться.

Чтобы удалить и их, например убрав все генерируемые в процессе сборки файлы с расширением \texttt{.o} с целью полной очистки сборки, нужно добавить параметр \lstinline{-x}


\begin{lstlisting}[
language = cmd,
numbers = none
]
git clean -d -n -x
\end{lstlisting}


\subsection{Подписи с помощью GPG}

\subsubsection{Общие сведения}

GPG (также известный как GnuPG) создавался как свободная альтернатива несвободному PGP. Утилита GPG может испольоваться для симметричного шифрования, но в основном используется для ассиметричного шифрования информации.

Если кратко, то при симметричном шифровании для шифроваки и расшифровки сообщения используется один ключ, а при ассиметричном шифровании используется два ключа -- публичный и приватный. Публичный используется для шифрования и его мы можем дать своим друзьям, а приватный -- для расшифровки, и его вы должны хранить в надежном месте.

При такой схеме расшифровать сообщение может только владелец приватного ключа (даже тот, кто зашифровал сообщение, не может произвести обратную операцию).

\remark{%
Сообщения, теги и пр. подписывают для того чтобы подтвердить, что сообщение написано именно вами и не изменялось в процессе передачи. Если сообщение будет изменено, то при проверке подписи это будет указано
}

Чтобы создать ключ, следует запустить утилиту командной строки \texttt{gpg}\footnote{Для операционной системы \texttt{MacOS X} \url{https://gpgtools.org/}} с аргументом \\\mbox{\lstinline{--full-generate-key}} (допустимо и с аргументом \lstinline{--gen-key}, но в этом случае не будет возможности выбрать несколько важных параметров\footnote{Выбор расширяется, елси добавить параметр \lstinline{--expert}})

\begin{lstlisting}[
language = cmd,
numbers = none
]
$ gpg --full-generate-key --expert

pg (GnuPG/MacGPG2) 2.2.17; Copyright (C) 2019 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Please select what kind of key you want:
(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
(7) DSA (set your own capabilities)
(8) RSA (set your own capabilities)
(9) ECC and ECC
...
\end{lstlisting}

\remark{%
Важно иметь в виду, что выбрав вариант (3) DSA (sign only) или (4) RSA (sign only) нельзя будет шифровать сообщения и файлы
}

Для RSA ключа размером 2048 бит вполне достаточно, но можно выбрать и размер до 4096 бит (а вот использовать ключи размера меньще 2048 бит небезопасно).

Если выбрать ограниченный срок действия ключа, то по истечению его срока ключ будет признан недействительным\footnote{Можно продлить срок действия ключа, пока он не истечет}.

В завершении генерируется ключ и добавляется в связку ключей. В связке ключей может находится множество ключей. Также на этом этапе создается \emph{сертификат отзыва} -- файл, с помощью которого созданный ключ можно отозвать (признать недействительным). Рекомендуется хранить его в безопасном месте.

Комметарии к сообщению \texttt{gpg}:

\begin{itemize}
	\item \texttt{rsa} -- алгоритм шифрования RSA,
	
	\item \texttt{2048} -- длина ключа,
	
	\item \texttt{1970-01-01} -- дата создания ключа,
	
	\item \texttt{2BB680...E426AC} -- отпечаток ключа. Его следует сверять при импортировании чужого публичного ключа -- у обоих сторон он должен быть одинаков, 
	
	\item \texttt{uid} -- идентификатор (user-id),
	
	\item \texttt{pub} -- публичный ключ,
	
	\item \texttt{sub} -- публичный подключ,
	
	\item \texttt{sec} -- секретный ключ,
	
	\item \texttt{ssb} -- секретный подключ.
	
   \item \texttt{S} -- подпись (signing),
   
   \item \texttt{C} -- подпись ключа (certification),
   
   \item \texttt{E} -- шифрование (encryption),
   
   \item \texttt{A} -- авторизация (authentication).
\end{itemize}

Файл конфигурации храниться по адресу \lstinline{~./gnupg/gpg.conf}. Пример файла

\begin{lstlisting}[
title = {\sffamily gpg.conf},
language = cmd,
numbers = none
]
keyid-format 0xlong
throw-keyids
no-emit-version
no-comments
\end{lstlisting}

Здесь \texttt{keyid-format 0xlong} -- формат вывода идентификатора ключа. У каждого ключа и подключа есть свой идентификатор. По умолчанию он не выводится. Допустимые значения:

\begin{itemize}
	\item \texttt{none} (не выводить),
	
	\item \texttt{short} (короткая запись),
	
	\item \texttt{0xshort} (короткая запись с префиксом <<0x>>),
	
	\item \texttt{long} (короткая запись с префиксом <<0x>>),
	
	\item \texttt{0xlong} (длинная запись с префиксом <<0x>>).
\end{itemize}

Далее \texttt{throw-keyids} -- не включать информацию о ключе в зашифрованное сообщение. Эта опция может быть полезна для анонимизации получателя сообщения.

\texttt{no-emit-version} -- не вставлять версию GPG в зашифрованное сообщение.

\texttt{no-comments} -- убирает все комментарии из зашифрованного сообщения.

В файле конфигурации эти опции записываются без префикса \lstinline{--}.

Команды и опции:

\begin{itemize}
	\item \lstinline{--armor / -a}: созадет ASCII (символьный) вывод. При шифровании GPG по умолчанию создает бинарный вывод. При использовании этой опции GPG кодирует информацию кодировкой Radix-64,
	
	\item \lstinline{--encrypt / -e}: зашифровать сообщение,
	
	\item \lstinline{--recipient / -r}: указать ключ, который будет использоваться для шифрования. Можно использовать информацию о пользователе (имя, почта), идентификатор ключа, отпечаток ключа,
	
	\item \lstinline{--decrypt / -d}: расшифровать сообщение,
	
	\item \lstinline{--sign / -s}: подписать сообщение. Подпись при этом будет располагаться отдельно самого сообщения,
	
	\item \lstinline{--clear-sign / --clearsign}: подписать сообщение. Подпись при этом сохраняется вместе с сообщением,
	
	\item \lstinline{--local-user / -u}: указать ключ, который будет использоваться для подписи. Схож с опцией \lstinline{--recipient}, но это не одно и то же,
	
	\item \lstinline{--verify}: проверить подпись,
	
	\item \lstinline{--list-keys / -k}: вывести список публичных ключей,
	
	\item \lstinline{--list-secret-keys / -K}: вывести список приватных ключей,
	
	\item \lstinline{--export}: экспортировать публичный ключ в файл, который потом можно куда-нибудь отправить,
	
	\item \lstinline{--import}: импортировать публичный ключ,
	
	\item \lstinline{--edit-key}: редактировать ключ,
	
	\item \lstinline{--expert}: режим <<эксперта>>.  
\end{itemize}

Примеры использования:

Зашфровать файл \texttt{decrypted.txt} в файл \texttt{encrypted.gpg} ключом \texttt{0x12345678}. При этом итоговый файл будет текстовым, а не бинарным

\begin{lstlisting}[
language = cmd,
numbers = none
]
gpg -a -r 0x12345678 -e decrypted.txt > encrypted.gpg
\end{lstlisting}

Расшифровать файл \texttt{encrypted.gpg} кючом \texttt{0x12345678} и сохранить его в файл \texttt{decrypted.txt}

\begin{lstlisting}[
language = cmd,
numbers = none
]
gpg -r 0x12345678 -d encrypted.gpg > decrypted.txt
\end{lstlisting}

Подписать файл \texttt{message.txt} ключом \texttt{0x12345678} и сохранить подпись в файл \texttt{sign.asc}

\begin{lstlisting}[
language = cmd,
numbers = none
]
gpg -u 0x12345678 -s message.txt > sign.asc
\end{lstlisting}

Подписать файл \texttt{message.txt} ключом \texttt{0x12345678} и записать сообщение с подписью в файл \texttt{message.gpg}

\begin{lstlisting}[
language = cmd,
numbers = none
]
gpg -r 0x12345678 --clearsign message.txt > message.gpg
\end{lstlisting}

Проверить подпись файла \texttt{message.txt}, которая записана в файле \texttt{message.asc}

\begin{lstlisting}[
language = cmd,
numbers = none
]
gpg --verify message.asc message.txt
\end{lstlisting}

Импортировать публичный ключ из файла \texttt{pubkey.gpg}

\begin{lstlisting}[
language = cmd,
numbers = none
]
gpg --import pubkey.gpg
\end{lstlisting}

Чтобы заставить \texttt{Git} использовать закрытый ключ, следует установить значение конфигурационного параметра \texttt{user.signingkey}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git config --global user.signingkey 0A46826A
\end{lstlisting}

Теперь \texttt{Git} будет использовать этот ключ по умолчанию для подписи тегов и коммитов.

\subsubsection{Подписи коммитов}

Чтобы подписать отдельный коммит, следует

\begin{lstlisting}[
language = cmd,
numbers = none
]
git commit -a -S -m 'signed commit'
\end{lstlisting}

Для просмотра и проверки таких подписей команда \texttt{git log} снабжена параметром \\\mbox{\lstinline{--show-signature}}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --show-signature -1
\end{lstlisting}

С помощью параметра \lstinline{--verify-signatures} можно заставить проверять слияния и отклонять их, если коммит не содержит доверенной GPG-подписи.

Если воспольоваться этим параметром при слиянии с веткой, содержащей неподписанные и недействительные коммиты, слияние выполнено не будет

\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge --verify-signatures non_verify_branch
\end{lstlisting}

Если же ветка, с которой осуществляется слияние, содержит только корректно подписанные коммиты, то команда \texttt{merge} сначала покажет все проверенные ею подписи, а потом перейдет непосредственно к слиянию

\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge --verify-signatures signed_branch
\end{lstlisting}

Можно также воспользоваться параметром \texttt{-S} команды \texttt{git merge} для подписи коммита, \emph{образующегося в результате слияния}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge --verify-signatures -S signed_branch
\end{lstlisting}

Итоговый коммит слияния получит подпись.


\subsection{Поиск}

По умолчанию команда \texttt{git grep} выполняет поиск среди всех файлов вашей рабочей директории. Параметр \texttt{-n} указывает номера строк, в которых была найдена заданная подстрока

\begin{lstlisting}[
language = cmd,
numbers = none
]
git grep -n 'section' *.tex
\end{lstlisting}

Вывести список файлов, в которых встречаются строки, удовлетворяющие поисковому шаблону, и дополнительно для каждого файла указать число  совпадений

\begin{lstlisting}[
language = cmd,
numbers = none
]
git grep --count 'section' *.tex
\end{lstlisting}

Вывести список файлов текущей директории (и ее поддиректорий) с указанием строк, удовлетворяющих поисковому шаблону; сводки по каждому файлу разделяютс пустой строкой и отображается заголовок файла

\begin{lstlisting}[
language = cmd,
numbers = none
]
git grep --break --heading 'section'
\end{lstlisting}

Чтобы увидеть историю функции или строки кода в кодовой базе следует исопльзовать конструкцию

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log -L :commit:cheat_sheet_git.tex
\end{lstlisting}

\subsection{Перезапись истории}

Во время работы с \texttt{Git} периодически возникает необходимость внести исправления в историю коммитов. Система \texttt{Git} примечательна тем, что позволяет вносить изменения в самый последний коммит. Можно скрыть наработки, работу над которыми пока не хотите продолжать или можно внести изменения в сделанные коммиты, придав истории совсем другой вид. И все это делается до выкладывания ваших наработок в общий доступ.

\subsubsection{Редактирование последнего коммита}

Отредактировать сообщение фиксации последнего коммита очень просто. Эта команда берет область индексироавния и включает в коммит всю обнаруженную там информацию

\begin{lstlisting}[
language = cmd,
numbers = none
]
git commit --amend
\end{lstlisting}

Эту технику нужно применять с осторожностью, так как она меняет контрольную сумму SHA-1 коммита. Как и в случае с небольшим перемещением, нельзя править последний коммит, если вы уже отправили его в общий доступ.

\subsubsection{Редактирование нескольких сообщений фиксации}

Чтобы отредактировать сообщения последних трех коммитов или сообщения только для некоторых коммитов из этой группы, в качестве аргумента команде \texttt{git rebase -i} передается родитель последнего коммита, который вы собираетесь менять, т.е.

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase -i HEAD~3
\end{lstlisting}

Эта команда служит для перемещения, то есть будут переписаны все коммиты в диапазоне \lstinline{HEAD~3..HEAD} вне зависимости от того, меняете вы для них сообщения или нет.

Ни в коем случае не включайте в этот набор коммиты, уже отправленные на центральный сервер, -- сделав так, вы запутаете других разработчиков, предоставив им альтернативную версию уже имеющихся изменений.

Важно запомнить, что коммиты перечисляются в обратном порядке. Самый старый коммит отображается сверху, так как именно он будет воспроизводится первым.

Нужно отредактировать сценарий таким образом, чтобы на коммитах, в которые вы хотите внести изменения, он останавливался. Для этого замените слово \texttt{pick} на \texttt{edit}. Например, для редактирования сообщения фиксации только в третьем коммите в файл следует внести вот такие изменения:

\begin{lstlisting}[
language = cmd,
numbers = none
]
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
\end{lstlisting}

Когда вы сохраните этот файл и закроете редактор, \texttt{Git} перебросит вас к последнему коммиту в списке и откроет для вас командную строку со следующим сообщением

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase -i HEAD~3
Stopped at 7482e0d... updated the gemspec to hopefully work better
You can amend the commit now, with 
git commit --amend
Once you're satisfied with your changes, run
git rebase --continue
\end{lstlisting}

Введите 
\begin{lstlisting}[
language = cmd,
numbers = none
]
git commit --amend
\end{lstlisting}

Измените сообщение фиксации и закройте редактор. Затем запустите команду

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase --continue
\end{lstlisting}

Данная команда автоматически применяет остальные два коммита и на этом заканчивает работу.

\subsubsection{Изменение порядка следования коммитов}

\emph{Перемещение в интерактивном режиме} (\lstinline{git rebase -i}) может также использоваться для изменения порядка следования коммитов или их удаления. К примеру, чтобы удалить коммит, связанный с добавлением файла \texttt{cat-file}, и изменить порядок следования двух оставшихся коммитов, нужно изменить сценарий перемещения. Вот исходный вариант

\begin{lstlisting}[
language = cmd,
numbers = none
]
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file 
\end{lstlisting}

А вот вариант сценария

\begin{lstlisting}[
language = cmd,
numbers = none
]
pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
\end{lstlisting}

После сохранения новой версии сценария и выхода из редактора система \texttt{Git} перемотает ветку до предка этих коммитов, применит коммиты \texttt{310154e} и \texttt{f7f3f6d}, после чего остановится.

\subsubsection{Объединение коммитов}

Инструмент интерактивного перемещения позволяет также превратить несколько коммитов в один коммит.

Как обычно работа начинается с команды \texttt{git rebase -i} (предварительно нужно определить номер родителя базового коммита, т.е. коммита, на который будет указывать \texttt{HEAD\~}, но этот коммит не будет отображаться в сценарии перемещения)
\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase -i HEAD~родитель_базового_коммита
\end{lstlisting}

Если вместо \texttt{pick} или \texttt{edit} указать \texttt{squash}, \texttt{Git} применит указанное изменение и непосредственно предшествующее ему изменение и заставит вас объединить сообщения фиксации. После сохранения результатов редактирования появится единственный коммит.

Важно помнить, что коммиты в сценарии перемещения отображаются в обратном порядке и что \texttt{squash} воздействует на \emph{предыдущий} коммит.

\subsubsection{Разбиение коммита}

Процедура разбиения коммита отменяет внесенные им изменения, затем индексирует его по частям и фиксирует столько раз, сколько коммитов вы в итоге хотите получить. Предположим вы хотите разбить средний коммит на две части. Вместо коммита <<update README formatting and added blame>> вы хотите сделать так, чтобы первый коммит обновлял и форматировал файл \texttt{README}, а второй добавлял файл \texttt{blame}. Для этого в сценарии \texttt{rebase -i} нужно заменить инструкцию для разбиваемого коммита на \texttt{edit}

\begin{lstlisting}[
language = cmd,
numbers = none
]
pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file 
\end{lstlisting}

После того как сценарий вернет вас в командную строку, вы отмените действие коммита и создадите из этих отмененных изменений нужное количество новых коммитов. Как только вы сохраните сценарий и выйдете из редактора, \texttt{Git} перейдет к родителю первого коммита из списка, применит превый коммит (\texttt{f7f3f6d}), затем второй (\texttt{310154e})  и вернет вас в консоль. Здесь изменения, внесенные этим коммитом, можно отменить командой \lstinline{git reset HEAD^}, которая эффективно возвращает все в предшествующее состояние, причем модифицированные файлы оказываются \emph{неиндексированными}. После этого можно начинать индексацию (\texttt{git add}) и фиксацию (\texttt{git commit}) файлов, пока у вас не появится \emph{несколько коммитов}. Затем останется выполить команду \verb|git rebase --continue|

\begin{lstlisting}[
title = {\sffamily Порядок действий},
language = cmd,
numbers = none
]
git rebase -i HEAD~3
git reset HEAD~
git add README
git commit -m 'updated README formatting'
git add lib/simplegit.rb
git git commit -m 'added blame'
git rebase --continue
\end{lstlisting}

\texttt{Git} применит последний коммит (\texttt{a5f4a0d}) из этого сценария, и история приобрете такой вид

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log -4 --pretty=format:'%h %s'
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
\end{lstlisting}

\remark{%
Эта процедура меняет контрольные суммы SHA всех коммитов в списке, поэтому важно следить за тем, чтобы список содержал только коммиты, которые еще не отправлялись в общее хранилище
}

\subsubsection{Переписывание истории с помощью \texttt{filter-branch}}

Существует еще один способ переписывания истории, к которому прибегают, когда при помощи сценария нужно внести изменения в большое количество коммитов, например, везде поменять ваш адрес электронной почты или убрать какой-то файл из всех коммитов. В таких случаях на помощь приходит команда \lstinline{filter-branch}, позволяющая переписывать большие фрагменты истории.

\paragraph{Удаление файла из всех коммитов} Часто случается так, что пользователь, необдуманно выполнив команду \texttt{git add}, включил в коммиты огромный бинарный файл и его требуется отовсюду удалить. Или вы можете сами включить в коммит файл, содержащий пароль, а потом решить сделать проект открытым.

Вот так выглядит удаление файла \texttt{passwords.txt} из истории проекта

\begin{lstlisting}[
language = cmd,
numbers = none
]
git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
\end{lstlisting}

Параметр \lstinline{--tree-filter} заставляет выполнить указанную команду после перехода к каждой следующей версии проекта, а затем повторно фиксирует результаты. В этом случае вы удаляете файл \texttt{passwords.txt} из \emph{каждого снимка состояния системы} вне зависимости от того, существует он или нет. Еще можно использовать \lstinline{--index-filter}, \lstinline{--msg-filter}, \lstinline{--commit-filter}, \lstinline{--tag-name-filter} и пр.

После выполнения этой команды может потребоваться <<перезагрузить>> историю коммитов с помощью интерактивного перемещения, например так
\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase -i HEAD~3
\end{lstlisting}

Сохранить и выйти. После этого можно посмотреть, что стало с историей коммитов \texttt{git log --oneline}.

Для удаления всех случайно зафиксированных \emph{резервных копий} файла, созданных текстовым редактором, можно написать\footnote{Эта команда удаляет из истории проекта все файлы, заканчивающиеся на \texttt{\~}}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git filter-branch --tree-filter 'rm -f *~' HEAD
\end{lstlisting}

Имена файлов при \emph{одноуровневом резервном копировании} формируются за счет добавления к исходному имени файла знака тильды \lstinline{~}. При \emph{многоуровневом} создании резервных копий к имени файла добавляется сочетание символов \lstinline{~n~}, где \texttt{n} -- это номер следующей резервной копии, начинающийся с единицы \cite[стр.~230]{sobel:2011}.

В общем случае применение команды \lstinline{git filter-branch} рекомендуется применять в тестовой ветке, а затем, если выяснится, что именно такой результат вам и нужен, выполнить полную перезагрузку ветки \texttt{master}.

Чтобы команда работала со всеми вашими ветками, добавьте к ней \lstinline{--all}.

\subsubsection{Изменение адресов электронной почты в глобальном масштабе}

Также часто возникает ситуация, когда пользователь перед началом работы забывает воспользоваться командой \lstinline{git config} и указать свой адрес электронной почты.

Изменить адреса электоронной почты можно так

\begin{lstlisting}[
language = cmd,
numbers = none
]
git filter-branch --commit-filter '
    if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
    then
         GIT_AUTHOR_NAME = "Scott Chacon";
         GIT_AUTHOR_EMAIL = "schacon@example.com";
         git commit-tree "$@";
    else
        git commit-tree "$@";
    fi ' HEAD
\end{lstlisting}

Эта команда по очереди переписывает все коммиты, вставляя туда ваш новый адрес электронной почты. Так как коммиты содержат значения SHA-1 своих предков, эта команда поменяет значения SHA \emph{всех} коммитов в истории, а не только тех, в которых был обнаружен указанный вами электронный адрес.








% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{chacon:2020}{ \emph{Чакон С.}, \emph{Штрауб Б.} Git для профессионального программиста. -- СПб.: Питер, 2020. -- 496~с. }
	
	\bibitem{sobel:2011}{ \emph{Собель М}. Linux. Администрирование и системное программирование. 2-е изд. -- СПб.: Питер, 2011. -- 880 с. }
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\end{document}
