\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Практика использования и наиболее полезные конструкции\\системы контроля версий  \texttt{Git}}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents


\section{Термины и определения}

\noindent\texttt{HEAD} -- специальный \textit{указатель} на текущую \emph{локальную ветку}, которая в свою очередь ссылается на последнее зафиксированное состояние, т.е. на \emph{последний} сделанный в ней \emph{коммит}. 

\section{Настройка строки приглашения в командной оболочке \texttt{bash}}

Для того чтобы настроить автодополнение команд и строку приглашения в командой оболочке \texttt{bash} первым делом нужно скачать файл \texttt{contrib/completion/git-completion.bash} и поместить его копию в домашнюю директорию
\begin{lstlisting}[
language = cmd,
numbers = none
]
$ curl -o ~/git-completion.bash https://raw.githubusercontent.com\
                /git/git/master/contrib/completion/git-completion.bash
$ echo '. ~/git-completion.bash' >> .bash_profile
\end{lstlisting}

Затем следует скачать файл \texttt{contrib/completion/git-prompt.sh} и сохранить его также в домашней директории
\begin{lstlisting}[
language = cmd,
numbers = none
]
$ curl -o ~/git-prompt.sh https://github.com/git/git/blob/master/contrib\
                /completion/git-prompt.sh
$ echo $'. ~/git-prompt.sh\nexport GIT_PS1_SHOWDIRTYSTATE=1\n
                export PS1=\'\w$(__git_ps1 " (%s)")\$ \'' >> .bash_profile
\end{lstlisting}

Выражение \verb|$'...'| умеет интерпретировать escape-последовательности типа \verb|\n|, \verb|\t| и пр., но выражение \verb|'\w$(__git_ps1 " (%s)")\$ '| стоящее в этой строке как подстрока должно быть заключено в одинарные кавычки, тогда как аргумент функции \verb|__git_ps1| должен быть заключен в двойные кавычки, поэтому одинарные кавычки подстроки приходится экранировать \verb|\'|. Конструкция \verb|$(...)| подставляет то, что возвращает выражение, заключенное в круглые скобки.

Однако строку приглашения можно сделать интереснее если переменной \texttt{PS1} передать
\begin{lstlisting}[
language = cmd,
title = {\sffamily .bash\_profile},
numbers = none
]
export PS1='\[\e[36m\][\u]\[\e[m\]:\[\e[33;1m\]\w$(__git_ps1 " (%s)")\[\e[m\]\$ '
\end{lstlisting}

Запись \verb|\u| означает имя пользователя, \verb|\w| как и раньше -- текущую директорию, а символ \verb|\$| означает <<сырой>> символ доллара как приглашение командной оболочки.

\section{Настройка системы \texttt{Git}}

Первым делом конфигурационные параметры \texttt{Git} берет из файла \texttt{/etc/gitconfig}, содержащего значения для всех пользователей системы и всех репозиториев этих пользователей. Параметр \verb|--system|, добавленный к команде \texttt{git config}, инициализирует чтение именно из этого файла и запись в него.

Затем \texttt{Git} смотрит файл \verb|~/.gitconfig| (или \verb|~/.config/git/config|), привязанный к конкретному пользователю. Чтение и запись этого файла активизирует передача параметра \verb|--global|.

Последним местом поиска конфигурационных параметров является файл в папке используемого в текущий момент репозитория (\verb|.git/config|). Находящиеся в этом файле значения связаны с конкретным репозиторием.

Итак
\begin{itemize}
	\item системный уровень: \verb|/etc/gitconfig| (флаг \verb|--system|),
	
	\item глобальный уровень: \verb|~/.gitconfig| (флаг \verb|--global|),
	
	\item локальный уровень (уровень репозитория): \verb|.git/config| (флаг \verb|--local|).
\end{itemize}

Значения с каждого уровня переопределяют значения, заданные на предыдущем уровне. Например, значения в файле \verb|.git/config| переписывают значения в файле \verb|/etc/gitconfig|, т.е. настройки репозитория имеют приоритет выше, чем настройки для всех пользователей и всех их репозиториев.

Вывести список всех настроек на системном, глобальном или локальном уровнях можно так
\begin{lstlisting}[
style = bash,
numbers = none
]
git config --system --list
git config --global --list
git config --local --list
\end{lstlisting}

\subsection{Параметр core.excludesfile}

Чтобы система \texttt{Git} не рассматривала определенные файлы как неотслеживаемые и не пыталась индексировать их при выполнении команды \texttt{git add}, следует создать шаблон в файле \texttt{.gitignore}. Но иногда возникает необходимость сделать так, чтобы система игнорировала определенные файлы для всех ваших репозиториев. Если вы работаете на компьютере с операционной системой \texttt{Mac OS X}, то вам знакомы файлы \texttt{.DS\_Store} или, например, файлы, которые заканчиваются на \verb|~|.

Параметр \texttt{core.exludesfile} позволяет записать файл \texttt{.gitignore}, действующий на глобальном уровне. Достаточно создать файл \verb|~/.gitignore_global| в вот таким содержимым
\begin{lstlisting}[
style = bash,
title = {\sffamily \~{}./gitignore\_global},
numbers = none
]
*~
.DS_Store
\end{lstlisting}

Теперь можно передать пусть до этого файла параметру \texttt{core.excludesfile}
\begin{lstlisting}[
style = bash,
numbers = none
]
git config --global core.excludesfile ~/.gitignore_global
\end{lstlisting}

\subsection{Внешние инструменты для слияния и индикации изменений}

Конфликты слияния можно решать, например, с помощью специальной программы Helix Visual Merge Tool (P4Merge) \url{https://www.perforce.com/downloads/visual-merge-tool}.

Создаем сценарий \texttt{extMerge.sh} для процедуры слияния, который будет вызывать бинарный файл \texttt{p4merge} со всеми переданными аргументами
\begin{lstlisting}[
style = bash,
title = {\sffamily \~{}/bin/extMerge.sh},
numbers = none
]
#!/bin/bash

"/c/Program Files (x86)/Perforce/p4merge" "$@"
\end{lstlisting}

Оболочка для команды \texttt{diff} проверяет наличие всех семи аргументов, которые ей должны передать, и отправляет два из них вашему сценарию слияния. По умолчанию \texttt{Git} передает команде \texttt{diff} следующие аргументы
\begin{lstlisting}[
style = bash,
numbers = none
]
путь старый-файл старый-хеш старые-права новый-файл новый-хеш новые-права
\end{lstlisting}

Так как нам требуются только второй и пятый аргументы, то есть имена старого и нового файлов, воспользуемся сценарием-оболочкой, который передаст только нужные сведения
\begin{lstlisting}[
style = cmd,
title = {\sffamily \~{}/bin/extDiff.sh},
numbers = none
]
#!/bin/bash

[[ $# -eq 7 ]] && ~/bin/extMerge.sh "$2" 
\end{lstlisting}

Заодно следует убедится, что наши инструменты представляют собой исполняемые файлы
\begin{lstlisting}[
numbers = none
]
chmod +x ~/bin/extMerge.sh
chmod +x ~/bin/extDiff.sh
\end{lstlisting}

Тепреь можно сделать так, чтобы конфигурационный файл вызывал наши инструменты разрешения конфликтов слияния и индикации добавленных изменений. Для этого потребуется несколько настроек:
\begin{itemize}
	\item параметр \verb|merge.tool| укажет \texttt{Git}, какую стратегию следует использовать,
	
	\item параметр \verb|mergetool.*.cmd| определит способ запуска команды,
	
	\item параметр \verb|mergetool.trustExitCode| даст \texttt{Git} понять, указывает код завершения программы на успешное разрешение конфликта или нет, 
	
	\item параметр \texttt{diff.external} объяснит \texttt{Git}, какой командой  следует воспользоваться для получения изменений.
\end{itemize}

Отредактируем файл \verb|~/.gitconfig|
\begin{lstlisting}[
style = bash,
title = {\sffamily \~{}/.gitconfig},
numbers = none
]
...
[merge]
    tool = extMerge.sh
[mergetool "extMerge.sh"]
    cmd = extMerge.sh "$BASE" "$LOCAL" "$REMOTE" "$MERGED"
    trustExitCode = false
[diff]
    external = extDiff.sh
\end{lstlisting}

После этого можно запустить команду \texttt{diff} 
\begin{lstlisting}[
style = bash,
numbers = none
]
git diff HEAD~1 HEAD~2
\end{lstlisting}

Если попытка слияния двух веток оканчивается конфликтом, запустите команду \texttt{git mergetool}. В результате откроется программа P4Merge, в которой можно будет разрешить конфликт.

В случае проблем с кодировкой нужно просто указать правильную \textit{File}~\textrightarrow~\textit{Character Encoding}.


\subsection{Форматирование и пробелы}

Если вы работатет в операционной системе \texttt{Windows}, а ваше коллеги нет, проблемы, связанные с символами конца строки, неизбежны. Дело в том, что в Windows-файлах для новых строк используется как символ перевода строки, так и символ возврата каретки, в то время как в Unix-подобных системах (MacOS X, Linux) -- только символ перевода строки.

Для того чтобы \texttt{Git} автоматически конвертировал окончания строк типа CRLF в тип LF в момент индексирования файла и производя обратное преобразование при выгрузке кода из репозитория в файловую систему, нужно задать параметр \texttt{core.autocrlf}
\begin{lstlisting}[
style = bash,
numbers = none
]
git config --global core.autocrlf true
\end{lstlisting}

\subsection{Псевдонимы}

Пример создания псевдонима для команды \texttt{status}
\begin{lstlisting}[
style = bash,
numbers = none
]
git config --global alias.st status
\end{lstlisting}

Теперь этот псевдоним можно в командной оболочке использовать
\begin{lstlisting}[
style = bash,
numbers = none
]
git st -sb
\end{lstlisting}

Можно создавать псевдонимы и для более сложных команд
\begin{lstlisting}[
style = bash,
numbers = none
]
git config --global alias.last 'log -1 HEAD'
\end{lstlisting}



\section{Фундаментальные концепции}

\subsection{Слежение}

При извлечении данных с удаленного репозитория (git fetch/pull) изменения будут объединяться с соответствующими ветками: \texttt{master} с \texttt{origin/master}, \texttt{feature} с \texttt{origin/feature}. Ветки объединяются разумеется не по имени, а за счет \emph{upstream tracking}. 

\subsection{Слияние}

При \emph{слиянии} веток снчала нужно перейти в ту ветку, в которую требуется слить данные, а затем применить команду \texttt{git merge}, т.е.

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout master
git merge server
\end{lstlisting}

\subsection{Перемещение}

При \emph{перемещении}\footnote{Т.е. чтобы повторить изменения из одной ветки в другой} данных из одной ветки в другую следует сначала перейти в ту ветку, из которой требуется перенести данные, а затем воспользоваться \texttt{git rebase}, т.е.

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout experiment
git rebase master
\end{lstlisting}

Набор коммитов из ветки, которая перемещается, устанавливается на самый верх ветки, в которую выполняется перемещение.

\subsection{Общая схема работы в небольшой команде}

Общая схема работы в небольшой команде:
\begin{itemize}
	\item Некоторое время вы работаете в тематической ветке (например, \texttt{issue54}), и когда приходит время, сливаете результаты своего труда в ветку \texttt{master}
	
\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout master
git merge issue54
\end{lstlisting}
	
	\item Решив, что пришло время поделиться своими наработками с коллегами, вы скачиваете данные с сервера (\texttt{git fetch origin}), и если там появились изменения, сливаете к себе ветку \texttt{origin/master}, т.е. \texttt{git merge origin/master},
	
	\item После чего содержимое ветки \texttt{master} можно отправить на сервер \texttt{git push origin master}.
\end{itemize}

\subsection{Типовые сценарии работы над проектом}

Можно выделить следующие типовые сценарии:
\begin{itemize}
	\item Выпус релизов (release),
	
	\item Исправление ошибок (bug fixing),
	
	\item Срочные исправления (hot fix),
	
	\item Разработка нескольких фич одновременно (features development),
	
	\item Выпуск определенных фич или выпуск по готовности.
\end{itemize}

В ветке \texttt{master} обычно хранится последняя выпущенная версия и она обновляется только от релиза к релизу. Не будет лишним сделать и tag с указанием версии, т.к. ветка может обновится.

Понадобиться еще одна ветка для основной разработки, та самая в которую будет все сливаться и которая будет продолжением ветки \texttt{master}. Ее будут тестировать и по готовности, во время релиза, все изменения будут сливать в \texttt{master}. Назовем ее \texttt{dev}.

Если требуется выпустить ветку \texttt{hotfix}, можно вернуться к состоянию \texttt{master} или к определенному тегу, создать там ветку \texttt{hotfix/version} и начать работу по исправлению критических изменений. Это не затрагивает проект и текущую разработку.

Для разработки фич удобно будет использовать ветки <<feature/feature\_name>>. Начинать ветку лучше с самых последних изменений и периодически подтягивать изменения из \texttt{dev} к себе. Чтобы сохранить историю простой и линейной, ветку лучше перестраивать на \texttt{dev} (\texttt{git rebase dev}).

Исправление мелких багов может идти напрямую в \texttt{dev}. Для мелких багов и изменений рекомендуется создавать локально временные ветки. Их не надо отправлять в глобальный репозиторий. Это только ваши временные ветки.

Схема исправления багов:
\begin{itemize}
	\item Исправление в ветке \texttt{dev} или отдельной,
	
	\item Получение изменений из \texttt{origin} (\texttt{git fetch origin dev}),
	
	\item Перестройка изменений на последнюю версию (\texttt{git rebase -i origin/dev}),
	
	\item Передача изменений в \texttt{origin} (\texttt{git push origin dev}).
\end{itemize}

Пример работы с фичами (это может быть большой баг, над которым работают несколько человек).

\subsubsection{Коротко-живущие ветки}

Обычно ветка создается с самого последнего варианта кодовой базы. В нашем случае с ветки \texttt{dev}
\begin{lstlisting}[
style = bash,
numbers = none
]
(dev)$ git fetch origin dev  # извлекаем изменения
\end{lstlisting}

Создаем ветку \texttt{feature/feature1} на базе ветки \texttt{origin/dev}, но не связываем их
\begin{lstlisting}[
style = bash,
numbers = none
]
(dev)$ git branch --no-track feature/feature1 origin/dev
\end{lstlisting}

Отправляем новую ветку в общий репозиторий, чтобы она была доступна другим
\begin{lstlisting}[
style = bash,
numbers = none
]
(dev)$ git push origin feature/feature1
\end{lstlisting}

Теперь работу над \texttt{feature1} можно вести в ветке \texttt{feature/feature1}. Спустя некоторое время в нашей ветке будет много коммитов, и работа над \texttt{feature1} будет закончена. При этом в \texttt{dev} тоже будет много изменений. И наша задача отдать наши изменения в \texttt{dev}.

Когда работа закончена, один разработчик должен предупредить другого, что он собирается <<слить>> изменения в \texttt{dev} и, например, удалить ветку
\begin{lstlisting}[
style = bash,
numbers = none
]
(feature/feature1)$ git fetch origin  # обновиться на всякий случай
(feature/feature1)$ git rebase -i origin/dev  # перестроить ветку feature/feature1 на ветке origin/dev. Нужно писать origin/dev, а не dev потому что после обновления ветка ушла вперед, а локальная ветка осталась на месте
(feature/feature1)$ git checkout dev
(dev)$ git merge feature/feature1  # сливаем в ветку dev
\end{lstlisting}

Делаем \texttt{push} и убираем ненужное
\begin{lstlisting}[
style = bash,
numbers = none
]
(dev)$ git push origin dev
(dev)$ git push origin :feature/feature1  # удаляем удаленную ветку
(dev)$ git branch -d feature/feature1  # удаляем локальную ветку
\end{lstlisting}

\subsubsection{Долго-живущие ветки}

Сложность долго-живущих веток в их поддержке и актуализации. Если делать все как описано выше то, вероятно быть беде: время идет, основная ветка меняется, проект меняется, а ваша фича основана на очень старом варианте. Когда настанет время выпустить фичу, она будет настолько выбиваться из проекта, что объединение может быть очень тяжелым или, даже, невозможным.

Именно поэтому, ветку нужно обновлять.


\subsection{Команда \texttt{git reset}}

В случае конструкции \texttt{git reset HEAD\~} команда \texttt{git reset} на \emph{первом шаге} переместит текущую локальную ветку на один элемент назад, то есть в данном случае ветка \texttt{master} будет указывать на предпоследний коммит. И в случае команды \verb|git reset --soft| этот же шаг окажется последним. Другими словами, команда \verb|git reset --soft HEAD~| просто перемещает ветку на один коммит назад (\emph{отменяет последний коммит}, т.е. отменяет действие команды \texttt{git commit}), не затрагивая ни \emph{область индексирования}, ни \emph{рабочую папку}. Если сейчас посмотреть статус \texttt{git status}, то файлы, которые вошли в отмененный коммит, будут проиндексированны и готовы к фиксации. Этим можно воспользоваться например так: создадим новый файл, проиндексируем его (\texttt{git add}), а затем все зафиксируем (\texttt{git commit}) вместе со старыми проиндексированными файлами.

Следующим действием команды \texttt{git reset} станет \emph{обновление области индексирования} путем добавления туда содержимого снимка, на который нацелен указатель \texttt{HEAD}. Если команда вызывается без аргументов (т.е. \texttt{git reset HEAD\~}), то на этом шаге работа команды заканчивается. Команда \texttt{git reset HEAD\~} не только отменяет последний коммит, но и убирает из области индексирования все находившиеся там файлы. То есть этот вариант команды \texttt{git reset} отменяет как \texttt{git commit}, так и \texttt{git add}.

Третьим действием команды \texttt{git reset} станет приведение рабочей папки к виду, который имеет область индексирования. До этой стадии команда работает при наличии параметра \verb|--hard|. То есть \verb|git reset --hard HEAD~| убирает последний коммит, результаты работы команд \texttt{git add} и \texttt{git commit} и все наработки из рабочей папки. Важно понимать, что только параметр \verb|--hard| делает команду \texttt{git reset} по настоящему опасной. Это один из немногочисленных случаев, когда \texttt{Git} реально удаляет данные. 

\paragraph{Заключение} команда \texttt{git reset} в определенном порядке переписывает три дерева, останавливаясь в указанном месте:
\begin{itemize}
	\item перемещает ветку, на которую нацелен указатель \texttt{HEAD} (и останавливается при наличии \verb|--soft|),
	
	\item приводит вид области индексирования в соответствие с данными, на которые нацелен указатель \texttt{HEAD} (и без параметра \verb|--hard| на этом останавливается),
	
	\item приводит вид рабочей папки в соответствие с видом области индексирования.
\end{itemize}

Кроме того команде \texttt{git reset} можно передавать путь. В этом случае команда пропускает первый этап и ограничивает свою работу определенным файлом или набором файлов.

Такое поведение имеет смысл, ведь указатель \texttt{HEAD} не может быть нацелен частично на один коммит, а частично на другой. А вот частичное обновление области индексирования и рабочей папки -- вполне реальная операция, поэтому команда \texttt{git reset} сразу переходит к этапам 2 и 3.

Команда \texttt{git reset file\_name} обратна по смыслу команде \texttt{git add file\_name}, т.е. \texttt{git add} индексирует файл, а \texttt{git reset} отменяет индексирование файла.

Можно явно указать коммит, из которого следует брать версию файла, например, \texttt{git reset eb43bf}.

\subsection{Команда \texttt{git fetch}}

Команда \texttt{git fetch} извлекает данные из удаленного репозитория без слияния. Общий синтаксис команды \texttt{git fetch} выглядит следующим образом
\begin{lstlisting}[
style = cmd,
numbers = none
]
git fetch [<опции>] [<имя_удаленного_репозитория> [<источник>:<цель>...]]
\end{lstlisting}

Здесь выражение \verb|<источник>:<цель>| -- \emph{спецификация ссылок}, где \verb|<источник>| -- шаблон для ссылок на сервере, а \verb|<цель>| -- место, куда эти ссылки будут записываться локально.

Посмотреть спецификацию ссылок, которая используется в проекте, можно так
\begin{lstlisting}[
style = bash,
numbers = none
]
$ cat .git/config
# выведет
[core]
    repositoryformatversion = 0
    filemode = false
    bare = false
    ...
    ignorecase = true
[remote "origin"]
    url = https://github.com/LeorFinkelberg/Cheat_sheet_bash.git
    fetch = +refs/heads/*:refs/remotes/origin/*  # <--
[branch "origin"]
    remote = origin
    merge = refs/heads/master
\end{lstlisting}

Строка, которая начинается с \texttt{fetch =}, обеспечивает проецирование имен в удаленном репозитории на имена в вашей локальной папке \texttt{.git}.

По сути, она сообщает системе \texttt{Git}: <<Все, что в \emph{удаленном} репозитории находится по адресу \verb|refs/heads|, должно попасть в папку моего \emph{локального} репозитория \verb|refs/remotes/origin|>>

Например, если требуется извлечь данные из \emph{удаленной} ветки \texttt{master} \emph{удаленного} репозитория с именем \texttt{origin} в \emph{локальную} ветку \texttt{mymaster}, то можно воспользоваться конструкцией
\begin{lstlisting}[
style = cmd,
numbers = none
]
git fetch origin master:refs/remotes/origin/mymaster
\end{lstlisting}

Можно задать набор спецификаций. Извлечь данные из нескольких веток посредством командой строки можно так
\begin{lstlisting}[
style = bash,
numbers = none
]
git fetch origin master:refs/remotes/origin/mymaster \
                 topic:refs/remotes/origin/topic
\end{lstlisting}

Посмотреть коммиты новой ветки можно, указав путь 
\begin{lstlisting}[
style = bash,
numbers = none
]
git log --oneline refs/remotes/origin/mymaster
\end{lstlisting}

Задать множественную спецификацию ссылок для извлечения данных можно и в конфигурационном файле. Чтобы все время получать обновления из веток \texttt{master} и \texttt{experiment}, добавьте следующие строки в конфигурационный файл
\begin{lstlisting}[
style = bash,
title = {\sffamily .git/config},
numbers = none
]
...
[remote "origin"]
    url = https://github.com/LeorFinkelberg/Cheat_sheet_bash.git
    fetch = +refs/heads/master:refs/remotes/origin/master
    fetch = +refs/heads/experiment:refs/remotes/origin/experiment
\end{lstlisting}

Если группа тестирования работает в некоторых ветках, а вам нужно получить данные из ветки \texttt{master} и из всех веток, используемой этой группой, добавьте в раздел конфигурации следующие строки
\begin{lstlisting}[
style = bash,
title = {\sffamily .git/config},
numbers = none
]
...
[remote "origin"]
    url = https://github.com/LeorFinkelberg/Cheat_sheet_bash.git
    fetch = +refs/heads/master:refs/remotes/origin/master
    fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*
\end{lstlisting}


\subsection{Команда \texttt{git push}}

Здорово, что извлекать данные можно с помощью ссылок, разделенных по пространствам имен, но сначала нужно дать группе тестирования возможность отправлять свои ветки в пространство имен \verb|qa/|. Эта задача решается через спецификации ссылок для команды \texttt{push}.

Вот как отправить ветку \texttt{master} (\emph{локальную}), принадлежащую группе тестирования, в ветку \verb|qa/master| на \emph{удаленном} сервере
\begin{lstlisting}[
style = bash,
numbers = none
]
git push origin master:refs/heads/qa/master
\end{lstlisting}

Если нужно, чтобы система \texttt{Git} автоматически делала это при каждом запуске команды \texttt{git push origin}, добавьте в конфигурационный файл значения переменной \texttt{push}
\begin{lstlisting}[
style = bash,
title = {\sffamily .git/config},
numbers = none
]
...
[remote "origin"]
    url = https://github.com/LeorFinkelberg/Cheat_sheet_bash.git
    fetch = +refs/heads/master:refs/remotes/origin/master
    push = +refs/heads/master:refs/heads/qa/master
\end{lstlisting}

В результате команда \texttt{git push origin} по умолчанию будет отправлять \emph{локальную} ветку \texttt{master} в ветку \verb|qa/master| на \emph{удаленном} сервере.

По сути мы просто копируем файл \texttt{master} из \verb|refs/heads/|, который содержит хеш-код последнего коммита текущей ветки, в \verb|refs/heads/qa/|.

\subsection{Ликвидация ссылок}

Спецификацию ссылок, кроме всего прочего, можно использовать для удаления ссылок с сервера. Это может выглядеть так
\begin{lstlisting}[
style = bash,
numbers = none
]
git push origin :topic
\end{lstlisting}

Так как спецификация ссылок задается в формате \verb|<источнк>:<цель>|, опустив часть \verb|<источник>|, мы по сути, скажем, что тематическую ветку на удаленном сервере следует сделать пустой, и это приведет к ее ликвидации.

Удалить удаленную ветку после перемещения
\begin{lstlisting}[
style = bash,
numbers = none
]
git push origin :feature/feature1
\end{lstlisting}

И удалить эту ветку локально
\begin{lstlisting}[
style = bash,
numbers = none
]
git branch -d feature/feature1
\end{lstlisting}



\section{Конфликты слияния}

\subsection{Создание коммитов слияния}

Перед потенциально конфликтным слиянием первым делом следует по возможности очистить рабочую папку. Незаконченные наработки желательно либо \emph{зафиксировать} во временной ветке, либо \emph{скрыть}. Если на момент слияния в рабочей папке присутствуют несохраненные данные, есть риск их потерять.

При слиянии веток, истории коммитов которых не имеют общей базы, потребуется специальный аргумент \verb|--allow-unrelated-histories|, которые разрешает сливать такие ветки
\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge --allow-unrelated-histories
\end{lstlisting}

Если вы не ожидали конфликта слияния и не хотите занимается его разрешением, можно просто отменить результат слияния командой (в рабочей папке не должно быть незафиксированных изменений!)
\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge --abort
\end{lstlisting}

Затем можно выполнить команду (флаг \verb|-b| дополнительно выводит имя текущей ветки)
\begin{lstlisting}[
language = cmd,
numbers = none
]
git status -sb
\end{lstlisting}

Команда \verb|git merge --abort| пытается вернуть все в состояние, которое имело место до попытки слияния. Но если перед слиянием в рабочей папке находились \emph{незафиксированные} изменения, возвращение в исходное состояние может оказаться невозможным. Во всех остальных случаях оно прекрасно работает.

Если конфликт возникает преимущественно по причине пробельных символов, то может помочь специальный флаг \verb|-Xignore-all-space| или \verb|-Xignore-space-change|.

Еще бывает удобно сливать файлы в интерактивном режиме с помощью \verb|--patch|
\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout --patch otherbranch file_name.txt
\end{lstlisting}

Затем будет выведена строка
\begin{lstlisting}[
language = cmd,
numbers = none
]
(1/1) Apply this hunk to index and worktree [y,n,q,a,d,s,e,?]?
\end{lstlisting}

В простейшем случае можно применить все изменения сразу, выбрав \texttt{y}, или отказаться от них, выбрав \texttt{n}. Но еще можно попросить систему разбить блок изменений (так называемый ханк) на атомарные изменения с помощью \texttt{s}, а затем принимать или отклонять изменения по отдельности.

Рассмотрим пример. Предположим, у нас есть пара долгоживущих веток (\texttt{master} и \texttt{mundo}), в каждой из которых присутствует несколько коммитов, но при этом попытки их слияния не удаются по причине конфликта.

При попытке слить содержимое ветки получаем конфликт
\begin{lstlisting}[
language = cmd,
numbers = none
]
$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge faild; fix confilcts and then commit the result.
\end{lstlisting}

Хотелось бы понять, что именно стало причиной проблемы. Открыв файл, мы увидим примерно такую картину
\begin{lstlisting}[
language = cmd,
title = {\sffamily Так будет выглядеть файл hello.rb после `git merge mundo`},
numbers = none
]
#! /usr/bin/env ruby

# this function prints out A GREETING!
def hello
<<<<<<< HEAD
    puts 'hello Python'
=======
    puts 'HELLO MUNDO'
>>>>>>> whitespace
end

\end{lstlisting}

Теперь этот файл можно аккуратно изучить и поправить строки (удалить те, которые не нужны, и оставить те, которые нужны), а затем зафиксировать изменения с помощью \texttt{git commit}.

На обеих ветках в этот файл добавлялось некое содержимое, но некоторые коммиты модифицировали одни и те же строки, что и стало причиной конфликта.

На помощь приходит команда \verb|git checkout --conflict|, которая повторно выгружает содержимое файла и заменяет маркеры конфликта слияния. Это может пригодится в ситуации, когда требуется сбросить маркеры и снова попробовать разрешить конфликт. 

Параметру \verb|--conflict| можно передать значения \texttt{diff3} и \texttt{merge} (последнее используется по умолчанию). Значения \texttt{diff3} заставляет \texttt{Git} выводить помимо <<их>>, <<нашей>> еще и <<базовую>> версию файла
\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout --confilct=diff3 hello.rb
\end{lstlisting}

После применения этой команды (применяется она сразу после \texttt{git merge}) файл будет выглядеть так
\begin{lstlisting}[
language = cmd,
title = {\sffamily Так будет выглядеть файл hello.rb после `git checkout --conflict`},
numbers = none
]
#! /usr/bin/env ruby

# this function prints out A GREETING!
def hello
<<<<<<< ours
    puts 'hello Python'
||||||| base
    puts 'hello mundo'
=======
    puts 'HELLO MUNDO'
>>>>>>> theirs
end
\end{lstlisting}

Теперь файл можно поправить в ручную, удалив ненужные строки. Но требуется быть очень внимательным, потому как в этом режиме не все конфликты изменений будут отображаться. В отношении некоторых изменений \texttt{Git} сама принимает решение.

Команда \texttt{git checkout} также можно добавить параметры \verb|--ours| и \verb|--theirs|, которые позволяют быстро выбрать одну из версий файла, не выполняя слияния. Это особенно полезно в случае конфликта бинарных файлов, при которых можно выбрать одну из сторон.

Получить список всех уникальных коммитов, сделанных в любой из участвующих в слиянии веток можно следующим образом
\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --oneline --left-right HEAD...MERGE_HEAD
\end{lstlisting}

Можно вывести информацию об изменениях по каждому коммиту из сливаемых веток
\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --oneline --left-right -p HEAD...whitespace
\end{lstlisting}

Получить список только тех коммитов с каждой стороны слияния, которые касаются только файла, являющегося в данный момент причиной конфликта, можно, добавив параметр \verb|--merge|
\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --oneline --left-right --merge
\end{lstlisting}

Если добавить параметр \texttt{-p}, то получим список изменений, внесенных в файл, в котором возник конфликт
\begin{lstlisting}[
language = cmd,
numbers = none
]
git log -p --oneline --left-right --merge
\end{lstlisting}

\subsection{Отмена результатов слияния}

Если нежелательный \emph{коммит слияния} присутствует только в вашем \emph{локальном} репозитории, то проще и лучше всего переместить ветки, чтобы они указывали туда, куда нужно. Отменить последний коммит, а точнее отменить результат действия команды \texttt{git commit} (перемещаем ветку на один коммит назад), команды \texttt{git add} (обновляем область индексирования, удаляя из области индексирования файлы отмененного коммита) и удалить файл из рабочей папки, можно с помощью \texttt{git reset} со специальным ключом \verb|--hard|
\begin{lstlisting}[
language = cmd,
numbers = none
]
git reset --hard HEAD~
\end{lstlisting}

Недостатком этого метода является внесения изменений в историю, что может привести к проблемам при наличии репозитория общего доступа. Если другие пользователи работают с коммитами, которые вы собираетесь переписать, от использования команды \texttt{git reset} лучше отказаться.

Кроме того, данный подход не будет работать, если с момента слияния был создан хотя бы один новый коммит, -- перемещение ссылок, по сути, приведет к потере внесенных изменений.

Если перемещение указателя ветки в вашей ситуации не помогает, система \texttt{Git} дает возможность выполнить новый коммит, отменяющий все изменения, внесенные предыдущим коммитом. Эта операция называется восстановлением \texttt{revert}
\begin{lstlisting}[
language = cmd,
numbers = none
]
git revert -m 1 HEAD
\end{lstlisting}

Флаг \texttt{-m 1} указывает, какой из предков является <<основной веткой>> и подлежит сохранению. После слияния в ветку, на которую нацелен указатель \texttt{HEAD}, у нового коммита будет два предка: первый с указателем \texttt{HEAD} (родитель 1) и второй -- вершина сливаемой ветки (родитель 2).

Мы хотим отменить все изменения, внесенные слиянием родителя 2, сохранив все содержимое родителя 1.

Содержимое нового коммита \verb|^M| полностью совпадает с содержимым коммита ветки \texttt{master}, то есть вы можете начать работу, как будто слияния никогда не было, только коммиты, не входившие в слияние, \emph{все еще присутствуют в истории перемещений указателя} \texttt{HEAD} \cite[\strbook{282}]{chacon:2020}.

Лучше всего решить эту проблему отменой возвращения исходного слияния, то есть нужно добавить изменения, которые были отменены, и создать новый коммит слияния
\begin{lstlisting}[
language = cmd,
numbers = none
]
git revert ^M
\end{lstlisting}

Иногда вместо решения конфликта было бы лучше, чтобы система \texttt{Git} просто выбрала одну из версий, проигнорировав все остальное. В этом случае к команде \texttt{git merge} следует добавить параметр \texttt{-Xours} или \texttt{-Xtheirs}
\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge -Xours mundo
\end{lstlisting}

В данном случае вместо того чтобы добавить маркеры конфликта в файл система просто выберет файл из соответствующей ветки. При этом все прочие изменения, не приводящие к конфликту, сливаются успешно.

Еще для того чтобы <<откатить>> успешное слияние (т.е. такое слияние, при котором не создается коммита слияния, а просто вносятся изменения в файлы) бывает очень удобно воспользоваться командой \texttt{git reflog}, чтобы посмотреть историю изменений, а затем можно воспользоваться той же командой \verb|git reset --hard|\footnote{Ключ \texttt{-}\texttt{-hard} нужен для обновления рабочей папки, т.е. в файлах отмененного коммита будут отменены все изменения, связанные с этим коммитом. Другими словами файлы будут возвращены в состояние до появления отмененного коммита}, что бы перейти к нужному моменту истории, например
\begin{lstlisting}[
language = cmd,
numbers = none
]
git reset --hard HEAD@{1}
\end{lstlisting}

Посмотреть как был разрешен конфликт можно с помощью 
\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --cc -p
\end{lstlisting}

Команда \texttt{git checkout --conflict} позволяет вернуть файл в состояние конфликта
\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout --conflict=merge hello.rb
\end{lstlisting}

\subsection{Слияние поддеревьев}

Идея слияния поддеревьев состоит в том, что один из проектов проецируется во вложенную папку другого, и наоборот.

Рассмотрим пример добавления нового проекта в уже существующий, при этом код из первого проекта записывается в подпапку второго.

Первым делом добавим к нашему проекту приложение Rack. Мы присоединим его как удаленный репозиторий (\texttt{rack\_remote}) и выгрузим его содержимое в отдельную ветку (\texttt{rack\_branch})
\begin{lstlisting}[
numbers = none
]
git remote add rack_remote https://github.com/rack/rack
git fetch rack_remote
git checkout -b rack_branch rack_remote/master
\end{lstlisting}

Теперь корень проекта Rack находится в ветке \texttt{rack\_branch}, в то время как наш собственный проект находится в ветке \texttt{master}.

В рассматриваемой ситуации мы хотим выгрузить содержимое проекта Rack в подпапку нашего основного проекта. В \texttt{Git} это реализуется командной \texttt{git read-tree}. Она считывает корень дерева одной ветки в текущую область индексирования и рабочую ветку.

Мы просто вернемся в ветку \texttt{master} и извлечем содержимое \texttt{rack\_branch} в подпапку \texttt{rack} нашей ветки \texttt{master} основного проекта
\begin{lstlisting}[
numbers = none
]
git checkout master
git read-tree --prefix=rack/ -u rack_branch
\end{lstlisting}

При фиксации все это будет выглядеть как результат добавления во вложенную папку всех файлов из проекта Rack -- как будто мы просто скопировали их из архива. Все обновления проекта Rack можно получить, перейдя на его ветку и выполнив скачивание данных из удаленного репозитория
\begin{lstlisting}[
numbers = none
]
git checkout rack_branch
git pull
\end{lstlisting}

Скачанные изменения можно слить в нашу ветку ветку \texttt{master}. Чтобы извлечь изменения и предварительно заполнить сообщение фиксации, используем параметры \verb|--squash| и \verb|--no-commit| вместе с параметром \emph{стратегии слияния поддеревьев} \texttt{-s}
\begin{lstlisting}[
numbers = none
]
git checkout master
git merge --squash -s subtree --no-commit rack_branch
\end{lstlisting}

Ветки можно хранить в нашем репозитории с другими проектами, периодически сливая их в наш проект как поддеревья. В некотором смысле это удобно: например, фиксация состояния всего кода происходит в одном месте.

Для просмотра разницы содержимого подпапки \texttt{rack} и кода в ветке \texttt{rack\_branch} (это нужно, чтобы понять, не пришло ли время выполнить слияние) следует выполнить команду
\begin{lstlisting}[
numbers = none
]
git diff-tree -p rack_branch
\end{lstlisting}

\section{Подмодули}

\section{Пакеты}

Система \texttt{Git} умеет <<упаковывать>> данные в один файл. Существует разные сценарии, в которых такое поведение востребовано. Например, если в текущий момент нет доступа к общему серверу, а нужно переслать кому-то по электронной почте свои наработки, не передавая 40 коммитов командой \texttt{format-patch}.

Именно в таких случаях на помощь приходит команда \texttt{git bundle}. Она упакует в бинарный файл все данные, которые в обычной ситуации вы отправили бы на сервер командой \texttt{git push}, и этот файл можно будет без проблем переслать по электронной почте или записать на флеш-накопитель, а затем распаковать в целевой хранилище
\begin{lstlisting}[
language = cmd,
numbers = none
]
git bundle create repo.bundle HEAD master
\end{lstlisting}

Если репозиторий предназначен для клонирования на новом месте, в пакет добавляется еще и указатель \texttt{HEAD}, как и было сделано в данном случае.

Появится файл \texttt{repo.bundle} со всем необходимыми для воссоздания ветки \texttt{master} вашего репозитория. Теперь этот файл можно отправить по почте или записать на диск. 

Чтобы восстановить репозиторий из бинарного файла его можно клонировать в папку 
\begin{lstlisting}[
language = cmd,
numbers = none
]
$ git clone repo.bundle repo
$ cd repo
$ git log --oneline
\end{lstlisting}

Если указатель \texttt{HEAD} не входит в список ссылок, при распаковке нужно будет указать \verb|-b master| или другую присутствующую в пакете ветку, в противном случае система не будет знать, в какую ветку ей следует перейти, т.е.
\begin{lstlisting}[
language = cmd,
numbers = none
]
git clone -b master repo.bundle repo
\end{lstlisting}

Если нужно передать не все коммиты, а только несколько последних, то можно указать диапазон интересующих коммитов. Для этого мы снова воспользуемся командой \texttt{git bundle create}, передав ей \emph{имя} будущего \emph{пакета} и \emph{диапазон коммитов}, которые следует в этот пакет включить
\begin{lstlisting}[
language = cmd,
numbers = none
]
git bundle create commits.bundle 389b3f2..master
\end{lstlisting}

В данном случае в пакет будут включены коммиты, начиная с первого потомка коммита \texttt{389b3f2} и заканчивая последним коммитом ветки.

Теперь в нашей папке появился файл \texttt{commits.bundle}. Если его отправить коллеге, тот сможет импортировать наши коммиты в исходный репозиторий, даже если там параллельно велась некая работа.

Перед импортированием пакета в репозиторий можно посмотреть его содержимое
\begin{lstlisting}[
language = cmd,
numbers = none
]
git bundle verify commits.bundle
\end{lstlisting}

Команда проверяет корректность пакета и наличие всех предков коммитов, необходимых для правильного восстановления.

Чтобы посмотреть, с чем нам придется работать можно извлечь ветку \texttt{master} из переданного репозитория \texttt{commits.bundle} в другую ветку \texttt{other-master}
\begin{lstlisting}[
language = cmd,
numbers = none
]
git fetch commits.bundle master:other-master
\end{lstlisting}
а затем
\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout other-master
git log --oneline
\end{lstlisting}

\section{Переменные среды}

\texttt{Git} всегда работает внутри командной оболочки \texttt{bash} и пользуется для задания своего поведения некоторыми доступными в этой оболочке переменными среды.

Описание наиболее полезных переменных среды можно найти в \cite[\strbook{451}]{chacon:2020}

\subsection{Отладка}

\texttt{Git} может выступать и как система слежения.

Переменная \verb|GIT_TRACE| контролирует протоколирование действий, не поддающих ни в одну из заданных категорий
\begin{lstlisting}[
language = cmd,
numbers = none
]
$ GIT_TRACE=true git lga
\end{lstlisting}

Переменная \verb|GIT_TRACE_PERFORMANCE| отвечает за регистрацию сведений о производительности. Выводимые данные показывают, сколько времени занимали те или иные действия
\begin{lstlisting}[
language = cmd,
numbers = none
]
$ GIT_TRACE_PERFORMANCE=true git gc
18:25:54.205230 trace.c:475             performance: 0.002114576 s: git command: git pack-refs --all --prune
18:25:54.233231 trace.c:475             performance: 0.009720393 s: git command: git reflog expire --all
18:25:54.278234 read-cache.c:2308       performance: 0.000061270 s:  read cache .git/index
Enumerating objects: 220, done.
Counting objects: 100% (220/220), done.
Delta compression using up to 8 threads
Compressing objects: 100% (87/87), done.
Writing objects: 100% (220/220), done.
Total 220 (delta 128), reused 220 (delta 128), pack-reused 0
18:25:54.536249 trace.c:475             performance: 0.272991152 s: git command: git pack-objects --local --delta-base-offset .git/objects/pack/.tmp-23424-pack --keep-true-parents --honor-pack-keep --non-empty --all --reflog --indexed-objects --unpack-unreachable=2.weeks.ago
18:25:54.576251 trace.c:475             performance: 0.326025363 s: git command: git repack -d -l -A --unpack-unreachable=2.weeks.ago
18:25:54.615253 read-cache.c:2308       performance: 0.000111965 s:  read cache .git/index
18:25:54.622254 trace.c:475             performance: 0.011453979 s: git command: git prune --expire 2.weeks.ago
18:25:54.640255 trace.c:475             performance: 0.001036295 s: git command: git worktree prune --expire 3.months.ago
18:25:54.658256 trace.c:475             performance: 0.000840357 s: git command: git rerere gc
18:25:54.694258 trace.c:475             performance: 0.517178791 s: git command: 'C:\Program Files\Git\mingw64\bin\git.exe' gc
\end{lstlisting}

Переменная \verb|GIT_TRACE_SETUP| показывает информацию, собранную системой \texttt{Git} о репозитории и среде, с которой взаимодействует
\begin{lstlisting}[
language = cmd,
numbers = none
]
$ GIT_TRACE_SETUP=true git status
22:06:55.450824 trace.c:375             setup: git_dir: .git
22:06:55.451824 trace.c:376             setup: git_common_dir: .git
22:06:55.451824 trace.c:377             setup: worktree: E:/[WorkDirectory]/[LaTeX_project]/Cheat_sheet_Git
22:06:55.451824 trace.c:378             setup: cwd: E:/[WorkDirectory]/[LaTeX_project]/Cheat_sheet_Git
22:06:55.451824 trace.c:379             setup: prefix: (null)
22:06:55.451824 chdir-notify.c:65       setup: chdir from 'E:/[WorkDirectory]/[LaTeX_project]/Cheat_sheet_Git' to 'E:/[WorkDirectory]/[LaTeX_project]/Cheat_sheet_Git'
On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
    (use "git add <file>..." to update what will be committed)
    (use "git restore <file>..." to discard changes in working directory)
        modified:   cheat_sheet_git.pdf
        modified:   cheat_sheet_git.tex
        modified:   style_packages/podvoyskiy_article_extended.sty

no changes added to commit (use "git add" and/or "git commit -a")
\end{lstlisting}


\section{Конструкции \texttt{Git}}

\subsection{Создать новый репозиторий}

Создать новый репозиторий в текущей директории
\begin{lstlisting}[
style = bash,
numbers = none
]
git init
\end{lstlisting}

Создать новый репозиторий в указанной директории
\begin{lstlisting}[
style = bash,
numbers = none
]
git init path_to_dir
\end{lstlisting}

\subsection{Клонирование репозитория}

Клонировать удаленный репозиторий в директорию с именем \texttt{folder\_name}
\begin{lstlisting}[
style = bash,
numbers = none
]
git clone https://github.com/.../git-commands.git folder_name
\end{lstlisting}


\subsection{Настройка Git}

Задать глобальные настройки можно следующим образом

\begin{lstlisting}[
language = cmd,
numbers = none
]
git config --global user.name "[name]"
git config --global user.email "[email address]"
\end{lstlisting}

Для того чтобы \texttt{Git} при слияниях, которые сопроваждаются разрешением конфликтов, использовал кэш следует воспользоваться конструкцией

\begin{lstlisting}[
language = cmd,
numbers = none
]
git config --global rerere.enabled true
\end{lstlisting}

\subsection{Информация о снимке}

Вывести информацию о текущем снимке \texttt{HEAD}
\begin{lstlisting}[
language = cmd,
numbers = none
]
git cat-file -p HEAD
\end{lstlisting}

Вывести список файлов, попавших в родительский снимок \texttt{HEAD}, с рекурсией по поддиректориям
\begin{lstlisting}[
language = cmd,
numbers = none
]
git ls-tree -r HEAD~
\end{lstlisting}

Вывести список директорий
\begin{lstlisting}[
language = cmd,
numbers = none
]
git ls-tree -d HEAD
\end{lstlisting}

Вывести текущее содержимое индекса (снимок, предложенный для следующего коммита)
\begin{lstlisting}[
language = cmd,
numbers = none
]
git ls-files -s
\end{lstlisting}

Вывести список модифицированных файлов
\begin{lstlisting}[
language = cmd,
numbers = none
]
git ls-files -m
\end{lstlisting}

Вывести список <<прочих>> файлов, т.е. файлов, находящихся в текущей директории, но не вошедших в снимок
\begin{lstlisting}[
language = cmd,
numbers = none
]
git ls-files -o
\end{lstlisting}


\subsection{Добавление файлов в область индексирования}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git add file_name.py
git add .
\end{lstlisting}


\subsection{Фиксация изменений}

Зафиксировать измененное состояние

\begin{lstlisting}[
language = cmd,
numbers = none
]
git commit -m 'Initial commit'
\end{lstlisting}

Зафиксировать измененное состояние, пропустив область индексирования

\begin{lstlisting}[
language = cmd,
numbers = none
]
git commit -a -m 'Some comment'
\end{lstlisting}

Исправить комментарий последнего коммита. Комментарий последнего коммита будет перезаписан

\begin{lstlisting}[
language = cmd,
numbers = none
]
git commit -m 'New some comment' --amend
\end{lstlisting}

Чтобы исправить комментарий коммита (или комментарии нескольких коммитов), созданного некоторое время назад (т.е. речь идет не о последнем коммите) следует перейти в интерактивный режим с помощью команды

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase -i HEAD~15
\end{lstlisting}
затем в открывшемся файле заменить <<pick>> на <<reword>> (изменить комментарий коммита), сохранить файл и закрыть его.

Далее для каждого коммита (помеченного <<reword>>) можно будет исправить комменатрий. После следует сохранить файл и закрыть его. В завершении требуется залить данные на удаленный сервер в принудительном режиме, т.е.
\begin{lstlisting}[
language = cmd,
numbers = none
]
git push --force
\end{lstlisting}


\subsection{Удаление файлов}

Удалить файл из \emph{области индексирования} и заодно удалить указанный файл из рабочей папки. Чтобы система \texttt{Git} перестала работать с файлом, его нужно удалить из числа отслеживаемых (точнее, убрать из области индексирования) и зафиксировать данное изменение 

\begin{lstlisting}[
language = cmd,
numbers = none
]
$ git rm file_name.py
\end{lstlisting}


Удалить файл из области индексирования\footnote{\texttt{Git} перестает следить за файлом, т.е. он становится \emph{неотслеживаемым}!}, но оставить его в рабочей папке. Данная команда в отличие от \texttt{git reset HEAD file\_name.py} может использоваться как до первой фиксации (\texttt{git commit}), так и после

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rm --cached file_name.py
\end{lstlisting}


Удалить все файлы с расширением \texttt{.log}\footnote{Символ \texttt{*} экранируется} из директории \texttt{log/}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rm log/\*.log
\end{lstlisting}


\subsection{Переименование файлов}

Переименовать файл

\begin{lstlisting}[
language = cmd,
numbers = none
]
git mv old_file_name new_file_name
\end{lstlisting}


Переименовать файл с использованием \texttt{\{..\}}
\begin{lstlisting}[
language = cmd,
numbers = none
]
git mv test_file{,_new}.py
\end{lstlisting}


\subsection{Просмотр истории коммитов}

Вывести историю коммитов

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log
\end{lstlisting}


Вывести историю коммитов, ограничившись последними двумя, с указанием разницы, которую внес каждый коммит

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log -p -2
\end{lstlisting}

Вывести историю коммитов с краткой статистикой

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --stat
\end{lstlisting}

Вывести историю коммитов с указанием сокращенного варианта хеш-кода коммита и комментария

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --pretty=format:'%h %s'
\end{lstlisting}


Вывести историю коммитов за последние 2 недели

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --since=2.week
\end{lstlisting}


Вывести историю коммитов с захватом интересующего слова в коммите, ограничившись последними двумя

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --grep='key word' -2
\end{lstlisting}


Вывести историю коммитов, которые попали в заданный временной диапазон

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --since='2020-03-01 10:00' --before ='2020-03-01 11:00'
\end{lstlisting}


Вывести историю коммитов с указанием сокращенного хеш-кода коммита, тегов, текущей векти и собственно коммита

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --oneline
\end{lstlisting}


Вывести историю коммитов, показывая места расположения указателей и точек расхождения

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --oneline --decorate --all --graph
\end{lstlisting}

Отобразить только те не подвергавшиеся слиянию коммиты из ветки \texttt{origin/master}, которых нет в ветке \texttt{issue54}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --no-merges issue54..origin/master
\end{lstlisting}

Провести слияние веток только с помощью перемотки вперед\footnote{Перемотка вперед возможна, если на графе коммитов существует прямой путь от последнего коммита более короткой ветки до последнего коммита более длинной ветки} (fast-forward)
\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge --ff-only branch_name
\end{lstlisting}

Вывести информацию о том чем ветка \texttt{origin/master} будет отличаться от ветки \texttt{master}\footnote{Этот прием бывает полезен тогда, когда требуется предварительно посмотреть данные, которые будут слиты в ветку} (каких коммитов нет в ветке \texttt{origin/master})

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log origin/master..master -p
\end{lstlisting}

Еще данный синтаксис часто используется для просмотра информации, которую вы собираетесь отправить на удаленный сервер

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log origin/master..HEAD
\end{lstlisting}
или короткий вариант
\begin{lstlisting}[
language = cmd,
numbers = none
]
git log origin/master..
\end{lstlisting}
так как \texttt{Git} вместо пропущенного фрагмента подставляет \texttt{HEAD}.

Вывести информацию из журнала ссылок\footnote{Этот способ работает только для данных, которые все еще находятся в журнале ссылок, поэтому его невозможно исопльзовать для просмотра коммитов, возраст которых превышает несколько месяцев}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log -g master
\end{lstlisting}


\subsection{Отмена индексирования}

Отменить индексирование файла (файл удаляется из области индексирования). Данная команда может применяться только после первой фиксации (\texttt{git commit})

\begin{lstlisting}[
language = cmd,
numbers = none
]
git reset HEAD file_name.py
\end{lstlisting}

\subsection{Отмена коммитов и перемещение по истории}

\remark{%
Все коммиты, которые были отправлены в удаленный репозиторий, должны отменяться ТОЛЬКО новыми коммитами (\texttt{git revert}), чтобы избежать проблем с историей разработки у других разработчиков
}

Создать новый коммит, отменяющий изменения последнего коммита без запуска редактора
\begin{lstlisting}[
style = bash,
numbers = none
]
git revert HEAD --no-edit
\end{lstlisting}

Создать новый коммит, отменяющий изменения, внесенные коммитом с указанным хеш-кодом
\begin{lstlisting}[
style = bash,
numbers = none
]
git revert b9533bb --no-edit
\end{lstlisting}

Все команды, приведенные ниже можно выполнять ТОЛЬКО, если коммиты еще \emph{не были отправлены} в удаленный репозиторий
\begin{lstlisting}[
style = bash,
numbers = none
]
git commit --amend -m 'New commit-message' # создать новый коммит на основе обновленной области индексирования и задать новое сообщение фиксации
git reset --hard @~  # передвинуть ветку на предыдущий коммит, обновить область индексирования и рабочую папку; эквивалентно git reset --hard HEAD~
git reset --hard 75e2d51  # то же самое, но на коммит с указанным хеш-кодом
\end{lstlisting}

\subsection{Восстановление изменений}

Восстановить в рабочей директории указанный файл на момент указанного коммита
\begin{lstlisting}[
numbers = none
]
git checkout 34534534 index.html
\end{lstlisting}

Скопировать на текущую ветку изменения из указанного коммита и \emph{зафиксировать} эти изменения
\begin{lstlisting}[
numbers = none
]
git cherry-pick 454535
\end{lstlisting}

Скопировать на текущую ветку изменения из ветки \texttt{master} (2 последних коммита)
\begin{lstlisting}[
numbers = none
]
git cherry-pick master~2..master
\end{lstlisting}

Скопировать на текущую ветку изменения из указанного коммита, но \emph{не фиксировать}
\begin{lstlisting}[
numbers = none
]
git cherry-pick -n 3453455
\end{lstlisting}

Прервать конфликтный перенос коммитов
\begin{lstlisting}[
numbers = none
]
git cherry-pick --abort
\end{lstlisting}

Продолжить конфликтный перенос коммитов
\begin{lstlisting}[
numbers = none
]
git cherry-pick --continue
\end{lstlisting}


\subsection{Работа с удаленными репозиториями}

Добавить удаленный репозиторий под коротким именем \texttt{pb}. Теперь вместо полного URL можно использовать имя \texttt{pb}

\begin{lstlisting}[
numbers = none
]
git remote add pb https://github.com/paulboone/ticgit
\end{lstlisting}


\emph{Извлечь данные} из удаленного репозитория. Эта команда связывается с удаленным проектом и извлекает оттуда все пока отсутствующие в локальном репозитории данные. Она \emph{\color{red}не выполняет} автоматического слияния с ветками, и вообще никак не затрагивает эти ветки

\begin{lstlisting}[
language = cmd,
numbers = none
]
git fetch origin
\end{lstlisting}


Отправить данные локальной ветки \texttt{master} на удаленный репозиторий \texttt{origin}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin master
\end{lstlisting}


Передать данные от локальной ветки \texttt{serverfix} в ветку \texttt{awesomebranch} на удаленном репозитории

\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin serverfix:awesomebranch
\end{lstlisting}

Вывести информацию о конкретном удаленном репозитории \texttt{origin}

\begin{lstlisting}[
numbers = none
]
git remote show origin
\end{lstlisting}


Изменить имя удаленного репозитория с \texttt{pb} на \texttt{paul}. Теперь к ветке \texttt{pb/master} нужно будет обращаться по имени \texttt{paul/master}

\begin{lstlisting}[
numbers = none
]
git remote rename pb paul
\end{lstlisting}


Удалить ссылку на удаленный репозиторий

\begin{lstlisting}[
numbers = none
]
git remote rm paul
\end{lstlisting}


\subsection{Работа с тегами}

Вывести список доступных тегов

\begin{lstlisting}[
language = cmd,
numbers = none
]
git tag
\end{lstlisting}


Вывести список тегов, отвечающих поисковому  шаблону

\begin{lstlisting}[
language = cmd,
numbers = none
]
git tag -l 'v1.8.*'
git tag -l 'v0.2*.*'
\end{lstlisting}


Создать тег с комментарием. Тег привязывается к последнему коммиту

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log -a v1.4 -m 'My version 1.4'
\end{lstlisting}

Вывести информацию по тегу

\begin{lstlisting}[
language = cmd,
numbers = none
]
git show v1.4
\end{lstlisting}


Создать легковесный тег (просто не указываются \texttt{-a}, \texttt{-s}, \texttt{-m})

\begin{lstlisting}[
language = cmd,
numbers = none
]
git tag v1.4-lw
\end{lstlisting}


Отправить все теги на удаленный репозиторий. По умолчанию команда \texttt{git push} не отправляет теги на удаленный репозиторий

\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin --tags
\end{lstlisting}


\subsection{Работа с ветками}

Вывести список существующих веток

\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch
\end{lstlisting}

Показать все имеющиеся ветки (в том числе на удаленных репозиториях)
\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch -a
\end{lstlisting}

Показать список веток и последние коммиты в каждой из них
\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch -vv
\end{lstlisting}

Переименовать локально ветку \texttt{old\_branch\_name} в \texttt{new\_branch\_name}
\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch -m old_branch_name new_branch_name
\end{lstlisting}

Переименовать локально текущую ветку в \texttt{new\_branch\_name}
\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch -m new_branch_name
\end{lstlisting}

Переименовать ветку в удаленном репозитории
\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin :old_branch_name new_branch_name
\end{lstlisting}

Завершить процесс переименования
\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch --unset-upstream
\end{lstlisting}


Создать новую ветку

\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch testing
\end{lstlisting}

Переключиться на новую ветку

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout testing
\end{lstlisting}

Создать новую ветку и тут же переключитсья на нее

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout -b iss53
\end{lstlisting}


Внедрить внесенные изменения в готовый код

\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge hotfix
\end{lstlisting}

Удалить ветку 

\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch -d hotfix
\end{lstlisting}

Вывести ветки, НЕ объединенные с текущей веткой

\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch --no-marged
\end{lstlisting}


Создать \emph{локальную копию ветки} \texttt{serverfix} на основе \emph{удаленной ветки} \texttt{origin/serverfix}. В результате будет получена локальная ветка, которая начинается там же, где и ветка \texttt{origin/serverfix}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout -b serverfix origin/serverfix
\end{lstlisting}

\noindent или альтернативный вариант

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout --track origin/serverfix
\end{lstlisting}

Создать локальную копию ветки с именем \texttt{sf} на основе удаленной ветки \texttt{origin/serverfix}. Теперь локальная ветка \texttt{sf} поддерживает автоматический обмен данными с удаленной веткой \texttt{origin/serverfix}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout -b sf origin/serverfix
\end{lstlisting}


Вывести только те коммиты, которых нет в первой ветке (ветка \texttt{master})

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log master..contrib
\end{lstlisting}
или так
\begin{lstlisting}[
language = cmd,
numbers = none
]
git log contrib --not master
\end{lstlisting}
или так
\begin{lstlisting}[
language = cmd,
numbers = none
]
git log ^master contrib
\end{lstlisting}


Вывести только те наработки из \emph{тематической ветки}, которые появились там после расхождения с веткой \texttt{master}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git diff master...contrib
\end{lstlisting}

Вывести изменения, которые присутствуют только в ветке \texttt{master}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git diff origin/master..master
\end{lstlisting}

Для обращения к существующей ветке можно использовать краткую форму \texttt{@\{u\}}. К примеру, если мы следим из ветки \texttt{master} за веткой \texttt{origin/master}, то для краткости можно писать так

\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge @{u}
\end{lstlisting}
вместо
\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge origin/master
\end{lstlisting}

Вывести список веток \emph{наблюдения}. Все цифры представляют собой показатели, зафиксированные в момент последнего скачивания данных с каждого сервера. Данная команда не обращается к серверам, а просто сообщает локальные данные из кэша. Для получения актуальной информации о количестве новых коммитов на локальных и удаленных ветках следует извлечь данные со всех удаленных серверов и только затем воспользоваться этой командой, т.е.
\begin{lstlisting}[
language = cmd,
numbers = none
]
git fetch --all
git branch -vv
 iss53 7e424c3 [origin/iss53: ahead 2] forgot the brackets
 master 1ae2a45 [origin/master] deploying index fix
 serverfix 5ea463a [teamone/server-fix-good: ahead 3, behind] this should do it
 ...
\end{lstlisting} 

\subsection{Работа со ссылками}

Вывести список всех ссылок локального репозитория
\begin{lstlisting}[
style = bash,
numbers = none
]
git show-ref
\end{lstlisting}


\subsection{Отправка данных на удаленный репозиторий}

Для того чтобы отправить данные из локального репозитория на удаленный следует использовать конструкцию

\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin master
\end{lstlisting}

\noindent но предварительно необходимо слить данные из удаленного репозитория с помощью команды \texttt{git pull origin master} (однако делать надо это очень осторожно и в общем случае лучше воспользоваться сначала командной \texttt{git fetch}, а затем уже \texttt{git merge}). Кроме того, может потребоваться специальный флаг \verb|--allow-unrelated-histories|, разрешающий слияние несвязанных историй (то есть историй коммитов, не имеющих общей базы)

\begin{lstlisting}[
language = cmd,
numbers = none
]
git pull origin master --allow-unrelated-histories
\end{lstlisting}


\subsection{Перемещение данных}

Изменения, зафиксированные в одной ветке, повторить в другой ветке (в \texttt{Git} это называется \emph{перемещением}). Например, чтобы повторить изменения из ветки \texttt{experiment} в ветке \texttt{master}, следует сначала перейти в ту ветку, из которой требуется перенести изменения (ветка \texttt{experiment}), а затем воспользоваться командой \texttt{git rebase}\footnote{Работает это следующим образом: ищется общий предок двух веток (текущей ветки и ветки, в которую выполняется перемещение), вычисляется разница, вносимая каждым коммитом текущей ветки, и сохраняется во временных файлах. После этого текущая ветка сопоставляется тому же коммиту, что и ветка, в которую осуществляется перемещение, и одно за другим происходят все изменения}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout experiment
git rebase master
\end{lstlisting}


Внести изменения клиентской части (ветка \texttt{client}) в окончательную версию кода (ветка \texttt{master}), оставив изменения серверной части (ветка \texttt{server}) для дальнейшего тестирования. Другими словами, взять изменения клиентской части, не связанные с изменениями на серверной стороне, и воспроизвести их в ветке \texttt{master} можно следующим образом\footnote{По сути, команда приказывает <<перейти в ветку \texttt{client}, найти исправления от общего предка веток \texttt{client} и \texttt{server} и повторить их в ветке \texttt{master}>>}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase --onto master server client
\end{lstlisting}

Общий синтаксис команды
\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase --onto <на_какую_ветку_перестроить>
                      <с_какого_коммита_или_ветки> <по_какой_коммит_или_ветку>
\end{lstlisting}

Переместить изменения из ветки \texttt{server} в ветку \texttt{master}, вне зависимости от того, в какой ветке вы находитесь, позволяет команда \texttt{git rebase [main\_branch] [topic\_branch]}. Эта команда переключает на тематическую ветку (в данном случае -- на ветку \texttt{server}) и воспроизводит ее содержимое в основной ветке (\texttt{master})

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase master server
\end{lstlisting}

\remark{%
    При перемещении изменений из одной ветки в другую, нужно перейти на ту ветку, \emph{из которой} планируется переместить изменения
}

\subsection{Перемещение отдельного коммита}

Взять представленные в коммите изменения и попытаться применить их в текущей ветке. Команда извлечет изменения, появившиеся в коммите, но при этом измениться контрольная сумма SHA-1 коммита, так как у него другая дата применения

\begin{lstlisting}[
language = cmd,
numbers = none
]
git cherry-pick e43a6fd3e9488...
\end{lstlisting}


\subsection{Удаление коммитов}

Для того чтобы удалить послдений коммит следует сначала удалить коммит в локальном репозитории

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase -i HEAD~2
\end{lstlisting}
а затем отправить данные в форсированном режиме на удаленный репоизторий

\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin +master --force
\end{lstlisting}


\remark{%
После удаления коммита или после изменения комментария коммита обязательно нужно <<залить>> обновления на удаленный сервер с помощью \lstinline{git push origin master --force}
}


\subsection{Просмотр информации по коммитам}

Если требуется вывести информацию по коммиту (например, требуется выяснить что было удалено/добавлено в этот коммит), то можно обратиться к коммиту через его хеш-код

\begin{lstlisting}[
language = cmd,
numbers = none
]
git show 06e6bbc
\end{lstlisting}

Информацию по последнему коммиту можно посмотреть следующим образом

\begin{lstlisting}[
language = cmd,
numbers = none
]
git show master
\end{lstlisting}

\subsection{Ссылки на предков}

Для просмотра \emph{предыдущего коммита} достаточно написать \texttt{HEAD\^}, что означает <<родитель HEAD>>

\begin{lstlisting}[
language = cmd,
numbers = none
]
git show HEAD^
\end{lstlisting}

Вывести информацию по коммиту указанного файла на момент предыдущего от HEAD коммита
\begin{lstlisting}[
language = cmd,
numbers = none
]
git show @~:file_name.txt
\end{lstlisting}

Показать самый последний коммит, в описании которого встречает указанная строка
\begin{lstlisting}[
language = cmd,
numbers = none
]
git show -s :/'cherry-pick'
\end{lstlisting}

Для просмотра всех предков указанного коммита следует воспользоваться конструкцией
\begin{lstlisting}[
style = bash,
numbers = none
]
git log j345345^@
\end{lstlisting}


Другое распространенное обозначение \emph{предка} -- символ \lstinline{~}. Он также соответствует \emph{ссылке на первого родителя}, поэтому записи \lstinline{HEAD^} и \lstinline{HEAD~} эквивалентны. А вот если указать номер после символа \lstinline{~}, то проявятся различия между \lstinline{~} и \lstinline{^}.

Например, запись \lstinline{HEAD~2} означает <<первый предок первого предка>>, при этом происходит переход от заданного предка вглубь указанное число раз, т.е. \lstinline{HEAD~3} укажет на четвертый\footnote{Так как отсчет ведется, начиная со второго коммита от конца ветки} от конца ветки коммит.

После символа \lstinline{^} можно указать число: например, запись \lstinline{d921970^2} означает <<второй предок коммита d921970>>. Этот синтаксис применяется \underline{только} в случае \emph{коммитов слияния}, у которых существует несколько предков. \emph{Первый родитель} -- это ветка, на которой вы находились в момент слияния, а \emph{второй родитель} -- коммит на ветке, которая подверглась слиянию

\begin{lstlisting}[
language = cmd,
numbers = none
]
git show d921970^2
\end{lstlisting}

Указанные обозначения можно комбинировать. К примеру, второго родителя четвертого от конца ветки коммита (при условии, что это коммит слияния) можно получить, написав \lstinline{HEAD~3^2}.

\subsection{Диапазоны коммитов}

Вывести все коммиты, достижимые по ссылке \texttt{refA} или \texttt{refB}, но не достижимые по ссылке \texttt{refC}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log refA refB ^refC
git log refA refB --not refC
\end{lstlisting}

Вывести только те коммиты, которые есть либо в ветке \texttt{master}, либо в ветке \texttt{experiment}, но не в обеих ветках одновременно

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log master...experiment
\end{lstlisting}

С этой командой часто используют параметр \lstinline{--left-right}, позволяющий посмотреть, с какой стороны диапазона находится каждый коммит

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --left-right master...experiment
\end{lstlisting}

\subsection{Скрытие и очистка}

Часто во время работы над проектом, все еще находится в беспорядочном состоянии, возникает необходимость перейти в другую ветку и поработать над другим аспектом. Проблема в том, что фиксировать работу, сделанную наполовину, чтобы позже к ней вернуться вы не хотите. В такой ситуации на помощь приходит команда \texttt{git stash}.

Если, к примеру, вы отредактируете два файла и только один из них проиндексируете без фиксации результатов своей работы, то с помощью команды
\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash save
\end{lstlisting}
можно будет перейти на другую ветку, скрыв наработки в буфере.

\remark{%
По умолчанию команда \texttt{git stash} сохраняет только файлы из \emph{области индексирования}
}

Теперь можно легко менять ветки и работать над другими фрагментами проекта -- все изменения хранятся в стеке. Увидеть содержимое позволяет команда

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash list
\end{lstlisting}

Вернуть спрятанные в буфер изменения в рабочее состояние можно командой

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash apply
\end{lstlisting}

Если требуется вернуться к работе над версией, сохраненной в буфере ранее, следует указать ее номер

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash apply stash@{2}
\end{lstlisting}

\remark{%
Вообще говоря, нет необходимости возвращать содерижмое буфера в чистый рабочий каталог и в ту же ветку, из которой они были сохранены. Можно скрыть изменения одной ветки, перейти в другую и попытаться вставить изменнное состояние туда
}

После извлечения информации из буфера файлы, которые до помещения в буфер были проиндексированы, автоматически в это состояние не вернуться. Чтобы сразу вернуть данные из буфера в исходное состояние, нужно написать

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash apply --index
\end{lstlisting}

При этом команда \texttt{apply} только возвращает данные в ветку, но из стека они никуда не деваются. Убрать их из стека позволяет команда \texttt{git stash drop} с именем удаляемого файла

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash drop stash@{0}
\end{lstlisting}


Врочем, существует также команда
\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash pop
\end{lstlisting}
которая возвращает сохраненную в буфере информацию в ветку и немедленно удаляет ее из буфера.

\subsubsection{Более сложные варианты скрытия}

Чтобы не скрывать данные, которые были проиндексированы командой \texttt{git add}, следует написать

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash save --keep-index
\end{lstlisting}

Команда \texttt{git stash} по умолчанию сохраняет только данные из области индексирования, но параметр \lstinline{--include-untracked} или \lstinline{-u} заставляет систему \texttt{Git} сохранять также все \emph{неотслеживаемые файлы}.

Для того чтобы в интерактивном режиме указать \texttt{Git} какие файлы нужно скрыть, а какие нет, следует воспользоваться конструкцией

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash save --patch
\end{lstlisting}


\subsection{Отмена скрытых изменений}

Может возникнуть ситуация, когда после возвращения изменений из буфера вы выполняете некую работу, а затем хотите отменить изменеия, внесенные из буфера. Сделать это можно следующим образом: сначала нужно извлечь связанные с буфером исправления, а затем применить их в реверсивном виде

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash show -p stash@{0} | git apply -R
\end{lstlisting}

\remark{%
Если скрыть некие наработки, оставить их на некоторое время в буфере, а тем временем продолжить работу в ветке, из которой была скрыта информация, в итоге можно столкнуться с ситуацией, когда просто взять и вернуть данные из буфера не удастся.

Намного проще протестировать скрытые изменения командой \texttt{git stash branch branch\_name}. Она создает новую ветку, переходит к коммиту, в котором вы находились на момент скрытия работы, копирует в новую ветку содержимое буфера и очищает его, если изменения прошли успешно. Это удобный спсоб легко восстановить скрытые изменения и продолжить работу с ними в новой ветке
}



\subsection{Принудительно перезаписать локальные файлы}

Если требуется локальные файлы перезаписать файлами с удаленного сервера, то алгоритм следующий

\begin{lstlisting}[
language = cmd,
numbers = none
]
git fetch --all
get reset --hard origin/master
\end{lstlisting}

Команда \lstinline{git fetch --all} скачивает отсутствующие файлы с удаленного репозитория без попытки слить или переместить данные, а \lstinline{git reset --hard origin/master} <<сбрасывает>> ветку \texttt{master}. Опция \lstinline{--hard} изменяет все файлы в рабочем дереве таким образом, чтобы они совпадали с файлами из \texttt{master/origin}.

\subsection{Очистка рабочей папки}

В некоторых ситуациях лучше не скрывать результаты своего труда или файлы, а избавиться от них. Это можно сделать командой \texttt{git clean}. Удаление требуется, чтобы убрать мусор, сгенерированный путем слияния или внешними инструментами, или чтобы избавиться от артефактов сборки в процессе ее очистки.

С этой командой надо быть крайне аккуратным, так как она предназначена для удаления неотслеживаемых файлов из рабочей папки. Даже если вы передумаете, восстановить содержимое таких файлов, как правило, будет невозможно. Безопаснее воспользоваться командой \lstinline{git stash --all}, скрывающей из папки все содержимое, но с последующим его сохранением в буфере.

Предположим, вы все-таки хотите удалить командой \lstinline{git clean} мусорные файлы или очистить вышу рабочую папку. Для удаления из этой папки всех \emph{неотслеживаемых} файлов используйте команду \lstinline{git clean -f -d}\footnote{Параметр \lstinline{-f} означает принудительное удаление}, которая полностью очищает папку, убирая не только файлы, но и вложенные папки.

Бывает полезно перед действительным удалением посмотреть на результа имитационного удаления. Сделать это можно, добавив ключ \lstinline{-n}, т.е.


\begin{lstlisting}[
language = cmd,
numbers = none
]
git clean -d -n
\end{lstlisting}

По умолчанию команда \lstinline{git clean} удаляет только \emph{неотслеживаемые} файлы, не добавленные в список игнорированных, т.е. любой файл, имя которого совпадает с шаблоном в файле \texttt{.gitignore}, сохраниться.

Чтобы удалить и их, например убрав все генерируемые в процессе сборки файлы с расширением \texttt{.o} с целью полной очистки сборки, нужно добавить параметр \lstinline{-x}


\begin{lstlisting}[
language = cmd,
numbers = none
]
git clean -d -n -x
\end{lstlisting}


\subsection{Подписи с помощью GPG}

\subsubsection{Общие сведения}

GPG (также известный как GnuPG) создавался как свободная альтернатива несвободному PGP. Утилита GPG может испольоваться для симметричного шифрования, но в основном используется для ассиметричного шифрования информации.

Если кратко, то при симметричном шифровании для шифроваки и расшифровки сообщения используется один ключ, а при ассиметричном шифровании используется два ключа -- публичный и приватный. Публичный используется для шифрования и его мы можем дать своим друзьям, а приватный -- для расшифровки, и его вы должны хранить в надежном месте.

При такой схеме расшифровать сообщение может только владелец приватного ключа (даже тот, кто зашифровал сообщение, не может произвести обратную операцию).

\remark{%
Сообщения, теги и пр. подписывают для того чтобы подтвердить, что сообщение написано именно вами и не изменялось в процессе передачи. Если сообщение будет изменено, то при проверке подписи это будет указано
}

Чтобы создать ключ, следует запустить утилиту командной строки \texttt{gpg}\footnote{Для операционной системы \texttt{MacOS X} \url{https://gpgtools.org/}} с аргументом \\\mbox{\lstinline{--full-generate-key}} (допустимо и с аргументом \lstinline{--gen-key}, но в этом случае не будет возможности выбрать несколько важных параметров\footnote{Выбор расширяется, елси добавить параметр \lstinline{--expert}})

\begin{lstlisting}[
language = cmd,
numbers = none
]
$ gpg --full-generate-key --expert

pg (GnuPG/MacGPG2) 2.2.17; Copyright (C) 2019 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Please select what kind of key you want:
(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
(7) DSA (set your own capabilities)
(8) RSA (set your own capabilities)
(9) ECC and ECC
...
\end{lstlisting}

\remark{%
Важно иметь в виду, что выбрав вариант (3) DSA (sign only) или (4) RSA (sign only) нельзя будет шифровать сообщения и файлы
}

Для RSA ключа размером 2048 бит вполне достаточно, но можно выбрать и размер до 4096 бит (а вот использовать ключи размера меньще 2048 бит небезопасно).

Если выбрать ограниченный срок действия ключа, то по истечению его срока ключ будет признан недействительным\footnote{Можно продлить срок действия ключа, пока он не истечет}.

В завершении генерируется ключ и добавляется в связку ключей. В связке ключей может находится множество ключей. Также на этом этапе создается \emph{сертификат отзыва} -- файл, с помощью которого созданный ключ можно отозвать (признать недействительным). Рекомендуется хранить его в безопасном месте.

Комметарии к сообщению \texttt{gpg}:

\begin{itemize}
	\item \texttt{rsa} -- алгоритм шифрования RSA,
	
	\item \texttt{2048} -- длина ключа,
	
	\item \texttt{1970-01-01} -- дата создания ключа,
	
	\item \texttt{2BB680...E426AC} -- отпечаток ключа. Его следует сверять при импортировании чужого публичного ключа -- у обоих сторон он должен быть одинаков, 
	
	\item \texttt{uid} -- идентификатор (user-id),
	
	\item \texttt{pub} -- публичный ключ,
	
	\item \texttt{sub} -- публичный подключ,
	
	\item \texttt{sec} -- секретный ключ,
	
	\item \texttt{ssb} -- секретный подключ.
	
   \item \texttt{S} -- подпись (signing),
   
   \item \texttt{C} -- подпись ключа (certification),
   
   \item \texttt{E} -- шифрование (encryption),
   
   \item \texttt{A} -- авторизация (authentication).
\end{itemize}

Файл конфигурации храниться по адресу \lstinline{~./gnupg/gpg.conf}. Пример файла

\begin{lstlisting}[
title = {\sffamily gpg.conf},
language = cmd,
numbers = none
]
keyid-format 0xlong
throw-keyids
no-emit-version
no-comments
\end{lstlisting}

Здесь \texttt{keyid-format 0xlong} -- формат вывода идентификатора ключа. У каждого ключа и подключа есть свой идентификатор. По умолчанию он не выводится. Допустимые значения:

\begin{itemize}
	\item \texttt{none} (не выводить),
	
	\item \texttt{short} (короткая запись),
	
	\item \texttt{0xshort} (короткая запись с префиксом <<0x>>),
	
	\item \texttt{long} (короткая запись с префиксом <<0x>>),
	
	\item \texttt{0xlong} (длинная запись с префиксом <<0x>>).
\end{itemize}

Далее \texttt{throw-keyids} -- не включать информацию о ключе в зашифрованное сообщение. Эта опция может быть полезна для анонимизации получателя сообщения.

\texttt{no-emit-version} -- не вставлять версию GPG в зашифрованное сообщение.

\texttt{no-comments} -- убирает все комментарии из зашифрованного сообщения.

В файле конфигурации эти опции записываются без префикса \lstinline{--}.

Команды и опции:

\begin{itemize}
	\item \lstinline{--armor / -a}: созадет ASCII (символьный) вывод. При шифровании GPG по умолчанию создает бинарный вывод. При использовании этой опции GPG кодирует информацию кодировкой Radix-64,
	
	\item \lstinline{--encrypt / -e}: зашифровать сообщение,
	
	\item \lstinline{--recipient / -r}: указать ключ, который будет использоваться для шифрования. Можно использовать информацию о пользователе (имя, почта), идентификатор ключа, отпечаток ключа,
	
	\item \lstinline{--decrypt / -d}: расшифровать сообщение,
	
	\item \lstinline{--sign / -s}: подписать сообщение. Подпись при этом будет располагаться отдельно самого сообщения,
	
	\item \lstinline{--clear-sign / --clearsign}: подписать сообщение. Подпись при этом сохраняется вместе с сообщением,
	
	\item \lstinline{--local-user / -u}: указать ключ, который будет использоваться для подписи. Схож с опцией \lstinline{--recipient}, но это не одно и то же,
	
	\item \lstinline{--verify}: проверить подпись,
	
	\item \lstinline{--list-keys / -k}: вывести список публичных ключей,
	
	\item \lstinline{--list-secret-keys / -K}: вывести список приватных ключей,
	
	\item \lstinline{--export}: экспортировать публичный ключ в файл, который потом можно куда-нибудь отправить,
	
	\item \lstinline{--import}: импортировать публичный ключ,
	
	\item \lstinline{--edit-key}: редактировать ключ,
	
	\item \lstinline{--expert}: режим <<эксперта>>.  
\end{itemize}

Примеры использования:

Зашфровать файл \texttt{decrypted.txt} в файл \texttt{encrypted.gpg} ключом \texttt{0x12345678}. При этом итоговый файл будет текстовым, а не бинарным

\begin{lstlisting}[
language = cmd,
numbers = none
]
gpg -a -r 0x12345678 -e decrypted.txt > encrypted.gpg
\end{lstlisting}

Расшифровать файл \texttt{encrypted.gpg} кючом \texttt{0x12345678} и сохранить его в файл \texttt{decrypted.txt}

\begin{lstlisting}[
language = cmd,
numbers = none
]
gpg -r 0x12345678 -d encrypted.gpg > decrypted.txt
\end{lstlisting}

Подписать файл \texttt{message.txt} ключом \texttt{0x12345678} и сохранить подпись в файл \texttt{sign.asc}

\begin{lstlisting}[
language = cmd,
numbers = none
]
gpg -u 0x12345678 -s message.txt > sign.asc
\end{lstlisting}

Подписать файл \texttt{message.txt} ключом \texttt{0x12345678} и записать сообщение с подписью в файл \texttt{message.gpg}

\begin{lstlisting}[
language = cmd,
numbers = none
]
gpg -r 0x12345678 --clearsign message.txt > message.gpg
\end{lstlisting}

Проверить подпись файла \texttt{message.txt}, которая записана в файле \texttt{message.asc}

\begin{lstlisting}[
language = cmd,
numbers = none
]
gpg --verify message.asc message.txt
\end{lstlisting}

Импортировать публичный ключ из файла \texttt{pubkey.gpg}

\begin{lstlisting}[
language = cmd,
numbers = none
]
gpg --import pubkey.gpg
\end{lstlisting}

Чтобы заставить \texttt{Git} использовать закрытый ключ, следует установить значение конфигурационного параметра \texttt{user.signingkey}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git config --global user.signingkey 0A46826A
\end{lstlisting}

Теперь \texttt{Git} будет использовать этот ключ по умолчанию для подписи тегов и коммитов.

\subsubsection{Подписи коммитов}

Чтобы подписать отдельный коммит, следует

\begin{lstlisting}[
language = cmd,
numbers = none
]
git commit -a -S -m 'signed commit'
\end{lstlisting}

Для просмотра и проверки таких подписей команда \texttt{git log} снабжена параметром \\\mbox{\lstinline{--show-signature}}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --show-signature -1
\end{lstlisting}

С помощью параметра \lstinline{--verify-signatures} можно заставить проверять слияния и отклонять их, если коммит не содержит доверенной GPG-подписи.

Если воспольоваться этим параметром при слиянии с веткой, содержащей неподписанные и недействительные коммиты, слияние выполнено не будет

\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge --verify-signatures non_verify_branch
\end{lstlisting}

Если же ветка, с которой осуществляется слияние, содержит только корректно подписанные коммиты, то команда \texttt{merge} сначала покажет все проверенные ею подписи, а потом перейдет непосредственно к слиянию

\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge --verify-signatures signed_branch
\end{lstlisting}

Можно также воспользоваться параметром \texttt{-S} команды \texttt{git merge} для подписи коммита, \emph{образующегося в результате слияния}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge --verify-signatures -S signed_branch
\end{lstlisting}

Итоговый коммит слияния получит подпись.


\subsection{Поиск}

По умолчанию команда \texttt{git grep} выполняет поиск среди всех файлов вашей рабочей директории. Параметр \texttt{-n} указывает номера строк, в которых была найдена заданная подстрока

\begin{lstlisting}[
language = cmd,
numbers = none
]
git grep -n 'section' *.tex
\end{lstlisting}

Вывести список файлов, в которых встречаются строки, удовлетворяющие поисковому шаблону, и дополнительно для каждого файла указать число  совпадений

\begin{lstlisting}[
language = cmd,
numbers = none
]
git grep --count 'section' *.tex
\end{lstlisting}

Вывести список файлов текущей директории (и ее поддиректорий) с указанием строк, удовлетворяющих поисковому шаблону; сводки по каждому файлу разделяютс пустой строкой и отображается заголовок файла

\begin{lstlisting}[
language = cmd,
numbers = none
]
git grep --break --heading 'section'
\end{lstlisting}

Чтобы увидеть историю функции или строки кода в кодовой базе следует исопльзовать конструкцию

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log -L :commit:cheat_sheet_git.tex
\end{lstlisting}

\subsection{Перезапись истории}

Во время работы с \texttt{Git} периодически возникает необходимость внести исправления в историю коммитов. Система \texttt{Git} примечательна тем, что позволяет вносить изменения в самый последний коммит. Можно скрыть наработки, работу над которыми пока не хотите продолжать или можно внести изменения в сделанные коммиты, придав истории совсем другой вид. И все это делается до выкладывания ваших наработок в общий доступ.

\subsubsection{Редактирование последнего коммита}

Отредактировать сообщение фиксации последнего коммита очень просто. Эта команда берет область индексироавния и включает в коммит всю обнаруженную там информацию

\begin{lstlisting}[
language = cmd,
numbers = none
]
git commit --amend
\end{lstlisting}

Эту технику нужно применять с осторожностью, так как она меняет контрольную сумму SHA-1 коммита. Как и в случае с небольшим перемещением, нельзя править последний коммит, если вы уже отправили его в общий доступ.

\subsubsection{Редактирование нескольких сообщений фиксации}

Чтобы отредактировать сообщения последних трех коммитов или сообщения только для некоторых коммитов из этой группы, в качестве аргумента команде \texttt{git rebase -i} передается родитель последнего коммита, который вы собираетесь менять, т.е.

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase -i HEAD~3
\end{lstlisting}

Эта команда служит для перемещения, то есть будут переписаны все коммиты в диапазоне \lstinline{HEAD~3..HEAD} вне зависимости от того, меняете вы для них сообщения или нет.

Ни в коем случае не включайте в этот набор коммиты, уже отправленные на центральный сервер, -- сделав так, вы запутаете других разработчиков, предоставив им альтернативную версию уже имеющихся изменений.

Важно запомнить, что коммиты перечисляются в обратном порядке. Самый старый коммит отображается сверху, так как именно он будет воспроизводится первым.

Нужно отредактировать сценарий таким образом, чтобы на коммитах, в которые вы хотите внести изменения, он останавливался. Для этого замените слово \texttt{pick} на \texttt{edit}. Например, для редактирования сообщения фиксации только в третьем коммите в файл следует внести вот такие изменения:

\begin{lstlisting}[
language = cmd,
numbers = none
]
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
\end{lstlisting}

Когда вы сохраните этот файл и закроете редактор, \texttt{Git} перебросит вас к последнему коммиту в списке и откроет для вас командную строку со следующим сообщением

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase -i HEAD~3
Stopped at 7482e0d... updated the gemspec to hopefully work better
You can amend the commit now, with 
git commit --amend
Once you're satisfied with your changes, run
git rebase --continue
\end{lstlisting}

Введите 
\begin{lstlisting}[
language = cmd,
numbers = none
]
git commit --amend
\end{lstlisting}

Измените сообщение фиксации и закройте редактор. Затем запустите команду

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase --continue
\end{lstlisting}

Данная команда автоматически применяет остальные два коммита и на этом заканчивает работу.

\subsubsection{Изменение порядка следования коммитов}

\emph{Перемещение в интерактивном режиме} (\lstinline{git rebase -i}) может также использоваться для изменения порядка следования коммитов или их удаления. К примеру, чтобы удалить коммит, связанный с добавлением файла \texttt{cat-file}, и изменить порядок следования двух оставшихся коммитов, нужно изменить сценарий перемещения. Вот исходный вариант

\begin{lstlisting}[
language = cmd,
numbers = none
]
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file 
\end{lstlisting}

А вот вариант сценария

\begin{lstlisting}[
language = cmd,
numbers = none
]
pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
\end{lstlisting}

После сохранения новой версии сценария и выхода из редактора система \texttt{Git} перемотает ветку до предка этих коммитов, применит коммиты \texttt{310154e} и \texttt{f7f3f6d}, после чего остановится.

\subsubsection{Объединение коммитов}

Инструмент интерактивного перемещения позволяет также превратить несколько коммитов в один коммит.

Как обычно работа начинается с команды \texttt{git rebase -i} (предварительно нужно определить номер родителя базового коммита, т.е. коммита, на который будет указывать \texttt{HEAD\~}, но этот коммит не будет отображаться в сценарии перемещения)
\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase -i HEAD~родитель_базового_коммита
\end{lstlisting}

Если вместо \texttt{pick} или \texttt{edit} указать \texttt{squash}, \texttt{Git} применит указанное изменение и непосредственно предшествующее ему изменение и заставит вас объединить сообщения фиксации. После сохранения результатов редактирования появится единственный коммит.

Важно помнить, что коммиты в сценарии перемещения отображаются в обратном порядке и что \texttt{squash} воздействует на \emph{предыдущий} коммит.

\subsubsection{Разбиение коммита}

Процедура разбиения коммита отменяет внесенные им изменения, затем индексирует его по частям и фиксирует столько раз, сколько коммитов вы в итоге хотите получить. Предположим вы хотите разбить средний коммит на две части. Вместо коммита <<update README formatting and added blame>> вы хотите сделать так, чтобы первый коммит обновлял и форматировал файл \texttt{README}, а второй добавлял файл \texttt{blame}. Для этого в сценарии \texttt{rebase -i} нужно заменить инструкцию для разбиваемого коммита на \texttt{edit}

\begin{lstlisting}[
language = cmd,
numbers = none
]
pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file 
\end{lstlisting}

После того как сценарий вернет вас в командную строку, вы отмените действие коммита и создадите из этих отмененных изменений нужное количество новых коммитов. Как только вы сохраните сценарий и выйдете из редактора, \texttt{Git} перейдет к родителю первого коммита из списка, применит превый коммит (\texttt{f7f3f6d}), затем второй (\texttt{310154e})  и вернет вас в консоль. Здесь изменения, внесенные этим коммитом, можно отменить командой \lstinline{git reset HEAD^}, которая эффективно возвращает все в предшествующее состояние, причем модифицированные файлы оказываются \emph{неиндексированными}. После этого можно начинать индексацию (\texttt{git add}) и фиксацию (\texttt{git commit}) файлов, пока у вас не появится \emph{несколько коммитов}. Затем останется выполить команду \verb|git rebase --continue|

\begin{lstlisting}[
title = {\sffamily Порядок действий},
language = cmd,
numbers = none
]
git rebase -i HEAD~3
git reset HEAD~
git add README
git commit -m 'updated README formatting'
git add lib/simplegit.rb
git git commit -m 'added blame'
git rebase --continue
\end{lstlisting}

\texttt{Git} применит последний коммит (\texttt{a5f4a0d}) из этого сценария, и история приобрете такой вид

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log -4 --pretty=format:'%h %s'
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
\end{lstlisting}

\remark{%
Эта процедура меняет контрольные суммы SHA всех коммитов в списке, поэтому важно следить за тем, чтобы список содержал только коммиты, которые еще не отправлялись в общее хранилище
}

\subsubsection{Переписывание истории с помощью \texttt{filter-branch}}

Существует еще один способ переписывания истории, к которому прибегают, когда при помощи сценария нужно внести изменения в большое количество коммитов, например, везде поменять ваш адрес электронной почты или убрать какой-то файл из всех коммитов. В таких случаях на помощь приходит команда \lstinline{filter-branch}, позволяющая переписывать большие фрагменты истории.

\paragraph{Удаление файла из всех коммитов} Часто случается так, что пользователь, необдуманно выполнив команду \texttt{git add}, включил в коммиты огромный бинарный файл и его требуется отовсюду удалить. Или вы можете сами включить в коммит файл, содержащий пароль, а потом решить сделать проект открытым.

Вот так выглядит удаление файла \texttt{passwords.txt} из истории проекта

\begin{lstlisting}[
language = cmd,
numbers = none
]
git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
\end{lstlisting}

Параметр \lstinline{--tree-filter} заставляет выполнить указанную команду после перехода к каждой следующей версии проекта, а затем повторно фиксирует результаты. В этом случае вы удаляете файл \texttt{passwords.txt} из \emph{каждого снимка состояния системы} вне зависимости от того, существует он или нет. Еще можно использовать \lstinline{--index-filter}, \lstinline{--msg-filter}, \lstinline{--commit-filter}, \lstinline{--tag-name-filter} и пр.

После выполнения этой команды может потребоваться <<перезагрузить>> историю коммитов с помощью интерактивного перемещения, например так
\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase -i HEAD~3
\end{lstlisting}

Сохранить и выйти. После этого можно посмотреть, что стало с историей коммитов \texttt{git log --oneline}.

Для удаления всех случайно зафиксированных \emph{резервных копий} файла, созданных текстовым редактором, можно написать\footnote{Эта команда удаляет из истории проекта все файлы, заканчивающиеся на \texttt{\~}}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git filter-branch --tree-filter 'rm -f *~' HEAD
\end{lstlisting}

Имена файлов при \emph{одноуровневом резервном копировании} формируются за счет добавления к исходному имени файла знака тильды \lstinline{~}. При \emph{многоуровневом} создании резервных копий к имени файла добавляется сочетание символов \lstinline{~n~}, где \texttt{n} -- это номер следующей резервной копии, начинающийся с единицы \cite[стр.~230]{sobel:2011}.

В общем случае применение команды \lstinline{git filter-branch} рекомендуется применять в тестовой ветке, а затем, если выяснится, что именно такой результат вам и нужен, выполнить полную перезагрузку ветки \texttt{master}.

Чтобы команда работала со всеми вашими ветками, добавьте к ней \lstinline{--all}.

\subsubsection{Изменение адресов электронной почты в глобальном масштабе}

Также часто возникает ситуация, когда пользователь перед началом работы забывает воспользоваться командой \lstinline{git config} и указать свой адрес электронной почты.

Изменить адреса электоронной почты можно так

\begin{lstlisting}[
language = cmd,
numbers = none
]
git filter-branch --commit-filter '
    if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
    then
         GIT_AUTHOR_NAME = "Scott Chacon";
         GIT_AUTHOR_EMAIL = "schacon@example.com";
         git commit-tree "$@";
    else
        git commit-tree "$@";
    fi ' HEAD
\end{lstlisting}

Эта команда по очереди переписывает все коммиты, вставляя туда ваш новый адрес электронной почты. Так как коммиты содержат значения SHA-1 своих предков, эта команда поменяет значения SHA \emph{всех} коммитов в истории, а не только тех, в которых был обнаружен указанный вами электронный адрес.

\subsection{Спецификация ссылок}

Рассмотрим более сложный случай проецирования удаленных веток на локальные
\begin{lstlisting}[
style = cmd,
numbers = none
]
git remote add origin https://github.com/LeorFinkelberg/Cheat_sheet_Git.git
\end{lstlisting}

Эта команда добавляет в файл \verb|.git/config| раздел, задающий имя удаленного репозитория (\texttt{origin}), его URL-адрес и \emph{спецификацию ссылок} для получения оттуда данных
\begin{lstlisting}[
numbers = none
]
[remote "origin"]
    url = https://github.com/LeorFinkelberg/Cheat_sheet_Git.git
    fetch = +refs/heads/*:refs/remotes/origin/*
\end{lstlisting}

Эта спецификация имеет следующий формат: по желанию символ \texttt{+}, за которым следует \verb|<источник>:<цель>|, где \verb|<источник>| -- шаблон для ссылок на сервере, а \verb|<цель>| -- место, куда эти ссылки будут записываться локально. Символ \texttt{+} заставляет \texttt{Git} обновлять ссылки, даже если речь идет не о перемотке.

К слову, значение переменной \texttt{fetch} можно узнать следующим образом
\begin{lstlisting}[
style = bash,
numbers = none
]
git config remote.origin.fetch
\end{lstlisting}

В случае настроек по умолчанию, которые автоматически используются командой \verb|git remote add|, \texttt{Git} извлекает все ссылки из папки \verb|refs/heads/| \emph{на сервере} и записывает их в \emph{локальную папку} \verb|refs/remotes/origin/|.

Если на сервере есть ветка \texttt{master}, локальный доступ к ее журналу можно получить так
\begin{lstlisting}[
style = cmd,
numbers = none
]
git log origin/master
git log remotes/origin/master
git log refs/remotes/origin/master
\end{lstlisting}

Все эти команды дают один и тот же результат, так как \texttt{Git} разворачивает каждую из них до состояния \verb|refs/remotes/origin/master|.

Если нужно, чтобы с удаленного сервера при каждом обращении к нему извлекалось содержимое только ветки \texttt{master}, а не всех подряд, измените соответствующую строку в конфигурационном файле
\begin{lstlisting}[
style = bash,
numbers = none
]
fetch = +refs/heads/master:refs/remotes/origin/master
\end{lstlisting}

Посмотреть настройки конфигурационного файла на уровне репозитория, связанные с извлечением данных, можно так
\begin{lstlisting}[
style = bash,
numbers = none
]
git config --local --list | grep 'fetch'
\end{lstlisting}

{\color{blue} Эта \emph{спецификация ссылки}, предлагаемой по умолчанию, будет использоваться командой\\\texttt{git fetch} при обращении к данному удаленному репозиторию.}

Если же вы хотите выполнить некое однократное действие, указать спецификацию можно в командной строке. Чтобы извлечь данные из \emph{удаленной} ветки \texttt{master} и поместить их в \emph{локальную} ветку \verb|origin/mymaster|, напишите
\begin{lstlisting}[
style = cmd,
numbers = none
]
git fetch origin master:refs/remotes/origin/mymaster
\end{lstlisting}

\subsection{Информация о файлах}

Вывести информацию о файлах и директориях, попавших в заданное дерево объекта, с указанием режима доступа, типа и контрольной суммы
\begin{lstlisting}[
style = bash,
numbers = none
]
git ls-tree HEAD
# выведет
100644 blob 9c8ab46e95aacdaed92b2dbcf6bf69965e115dd1    .gitignore
100644 blob 93ffc9c04dd7b32cdfb14b0db7af3fcf165917a2    README.md
100644 blob 411b170c34aeed793ae7984ccd2f657802a43300    cheat_sheet_git.pdf
100644 blob 9ffd86fa5acc6be4beed24f7b2c0508c1e222edf    cheat_sheet_git.tex
040000 tree 417bb89bd6f65dfa12a8a9d35343bf8c6c223ad0    style_packages
\end{lstlisting}

Вывести размер файла по его контрольной сумме
\begin{lstlisting}[
style = bash,
numbers = none
]
git cat-file -s 411b170c34aeed793ae7984ccd2f657802a43300 # 737387
\end{lstlisting}

\subsection{Перемещения}

Перестроить текущую ветку \texttt{dev} на локальной ветке \texttt{origin/dev} в интерактивном режиме
\begin{lstlisting}[
style = bash,
numbers = none
]
(dev)$ git rebase -i origin/dev
\end{lstlisting}

\section{Коллекция сценариев}

\subsection{Откат к состоянию до слияния}

Была ветка \texttt{fix}, в которой исправляли баг. Исправили, слили изменения из \texttt{fix} в \texttt{master}, но тут выяснилось, что это исправление ломает приложение. Нужно откатить ветку \texttt{master} к состоянию до слияния
\begin{lstlisting}[
style = bash,
numbers = none
]
# находимся в ветке fix, баг "исправлен"
git checkout master
git merge fix
# видим проблему, приложение сломалось
git checkout fix
git branch -f master ORIG_HEAD
\end{lstlisting}


% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{chacon:2020}{ \emph{Чакон С.}, \emph{Штрауб Б.} Git для профессионального программиста. -- СПб.: Питер, 2020. -- 496~с. }
	
	\bibitem{sobel:2011}{ \emph{Собель М}. Linux. Администрирование и системное программирование. 2-е изд. -- СПб.: Питер, 2011. -- 880 с. }
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\end{document}
