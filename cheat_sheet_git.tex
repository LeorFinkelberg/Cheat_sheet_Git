\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Наиболее полезные конструкции\\системы контроля версий  \texttt{Git}}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents


\section{Термины и определения}

\noindent\texttt{HEAD} -- специальный \textit{указатель} на текущую \emph{локальную ветку}, которая в свою очередь ссылается на последнее зафиксированное состояние, т.е. на \emph{последний коммит}.


\section{Фундаментальные концепции}

При \emph{слиянии} веток снчала нужно перейти в ту ветку, в которую требуется слить данные, а затем применить команду \texttt{git merge}, т.е.

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout master
git merge server
\end{lstlisting}


При \emph{перемещении}\footnote{Т.е. чтобы повторить изменения из одной ветки в другой} данных из одной ветки в другую следует сначала перейти в ту ветку, из которой требуется перенести данные, а затем воспользоваться \texttt{git rebase}, т.е.

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout experiment
git rebase master
\end{lstlisting}


Общая схема работы в небольшой команде:
\begin{itemize}
	\item Некоторое время вы работаете в тематической ветке (например, \texttt{issue54}), и когда приходит время, сливаете результаты своего труда в ветку \texttt{master}
	
\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout master
git merge issue54
\end{lstlisting}
	
	\item Решив, что пришло время поделиться своими наработками с коллегами, вы скачиваете данные с сервера (\texttt{git fetch origin}), и если там появились изменения, сливаете к себе ветку \texttt{origin/master}, т.е. \texttt{git merge origin/master},
	
	\item После чего содержимое ветки \texttt{master} можно отправить на сервер \texttt{git push origin master}.
\end{itemize}



\section{Конструкции \texttt{Git}}

\subsection{Натсройка Git}

Задать глобальные настройки можно следующим образом

\begin{lstlisting}[
language = cmd,
numbers = none
]
git config --global user.name "[name]"
git config --global user.email "[email address]"
\end{lstlisting}

Для того чтобы \texttt{Git} при слияниях, которые сопроваждаются разрешением конфликтов, использовал кэш следует воспользоваться конструкцией

\begin{lstlisting}[
language = cmd,
numbers = none
]
git config --global rerere.enabled true
\end{lstlisting}


\subsection{Добавление файлов в область индексирования}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git add file_name.py
git add .
\end{lstlisting}


\subsection{Фиксация изменений}

Зафиксировать измененное состояние

\begin{lstlisting}[
language = cmd,
numbers = none
]
git commit -m 'Initial commit'
\end{lstlisting}

Зафиксировать измененное состояние, пропустив область индексирования

\begin{lstlisting}[
language = cmd,
numbers = none
]
git commit -a -m 'Some comment'
\end{lstlisting}

Исправить комментарий последнего коммита. Комментарий последнего коммита будет перезаписан

\begin{lstlisting}[
language = cmd,
numbers = none
]
git commit -m 'New some comment' --amend
\end{lstlisting}

Чтобы исправить комментарий коммита (или несколько коммитов), созданного некоторое время назад (т.е. комментарий не последнего коммита) следует перейти в интерактивный режим с помощью команды

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase -i HEAD~15
\end{lstlisting}
затем в открывшемся файле заменить <<pick>> на <<reword>> (изменить комментарий коммита), сохранить файл и закрыть его. Далее для каждого коммита (помеченного <<reword>>) можно будет исправить комменатрий. Затем следует сохранить файл и закрыть его. В завершении требуется залить данные на удаленный сервер в принудительном режиме, т.е.
\begin{lstlisting}[
language = cmd,
numbers = none
]
git push --force
\end{lstlisting}


После нужно принудительно обновить удаленный репозиторий

\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin master --force
\end{lstlisting}


\subsection{Удаление файлов}

Удалить файл из \emph{области индексирования} и заодно удалить указанный файл из рабочей папки. Чтобы система \texttt{Git} перестала работать с файлом, его нужно удалить из числа отслеживаемых (точнее, убрать из области индексирования) и зафиксировать данное изменение 

\begin{lstlisting}[
language = cmd,
numbers = none
]
$ git rm file_name.py
\end{lstlisting}


Удалить файл из области индексирования\footnote{\texttt{Git} перестает следить за файлом, т.е. он становится \emph{неотслеживаемым}!}, но оставить его в рабочей папке. Данная команда в отличие от \texttt{git reset HEAD file\_name.py} может использоваться как до первой фиксации (\texttt{git commit}), так и после

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rm --cached file_name.py
\end{lstlisting}


Удалить все файлы с расширением \texttt{.log}\footnote{Символ \texttt{*} экранируется} из директории \texttt{log/}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rm log/\*.log
\end{lstlisting}


\subsection{Переименование файлов}

Переименовать файл

\begin{lstlisting}[
language = cmd,
numbers = none
]
git mv old_file_name new_file_name
\end{lstlisting}


Переименовать файл с использованием \texttt{\{..\}}
\begin{lstlisting}[
language = cmd,
numbers = none
]
git mv test_file{,_new}.py
\end{lstlisting}


\subsection{Просмотр истории коммитов}

Вывести историю коммитов

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log
\end{lstlisting}


Вывести историю коммитов, ограничившись последними двумя, с указанием разницы, которую внес каждый коммит

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log -p -2
\end{lstlisting}

Вывести историю коммитов с краткой статистикой

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --stat
\end{lstlisting}

Вывести историю коммитов с указанием сокращенного варианта хеш-кода коммита и комментария

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --pretty=format:'%h %s'
\end{lstlisting}


Вывести историю коммитов за последние 2 недели

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --since=2.week
\end{lstlisting}


Вывести историю коммитов с захватом интересующего слова в коммите, ограничившись последними двумя

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --grep='key word' -2
\end{lstlisting}


Вывести историю коммитов, которые попали в заданный временной диапазон

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --since='2020-03-01 10:00' --before ='2020-03-01 11:00'
\end{lstlisting}


Вывести историю коммитов с указанием сокращенного хеш-кода коммита, тегов, текущей векти и собственно коммита

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --oneline
\end{lstlisting}


Вывести историю коммитов, показывая места расположения указателей и точек расхождения

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --oneline --decorate --all --graph
\end{lstlisting}

Отобразить только те не подвергавшиеся слиянию коммиты из ветки \texttt{origin/master}, которых нет в ветке \texttt{issue54}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --no-merges issue54..origin/master
\end{lstlisting}

Вывести информацию о том чем ветка \texttt{origin/master} будет отличаться от ветки \texttt{master}\footnote{Этот прием бывает полезен тогда, когда требуется предварительно посмотреть данные, которые будут слиты в ветку} (каких коммитов нет в ветке \texttt{origin/master})

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log origin/master..master -p
\end{lstlisting}

Еще данный синтаксис часто используется для просмотра информации, которую вы собираетесь отправить на удаленный сервер

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log origin/master..HEAD
\end{lstlisting}
или короткий вариант
\begin{lstlisting}[
language = cmd,
numbers = none
]
git log origin/master..
\end{lstlisting}
так как \texttt{Git} вместо пропущенного фрагмента подставляет \texttt{HEAD}.

Вывести информацию из журнала ссылок\footnote{Этот способ работает только для данных, которые все еще находятся в журнале ссылок, поэтому его невозможно исопльзовать для просмотра коммитов, возраст которых превышает несколько месяцев}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log -g master
\end{lstlisting}


\subsection{Отмена индексирования}

Отменить индексирование файла (файл удаляется из области индексирования). Данная команда может применяться только после первой фиксации (\texttt{git commit})

\begin{lstlisting}[
language = cmd,
numbers = none
]
git reset HEAD file_name.py
\end{lstlisting}


\subsection{Работа с удаленными репозиториями}

Добавить удаленный репозиторий под коротким именем \texttt{pb}. Теперь вместо полного URL можно использовать имя \texttt{pb}

\begin{lstlisting}[
numbers = none
]
git remote add pb https://github.com/paulboone/ticgit
\end{lstlisting}


\emph{Извлечь данные} из удаленного репозитория. Эта команда связывается с удаленным проектом и извлекает оттуда все пока отсутствующие в локальном репозитории данные. Она \emph{\color{red}не выполняет} автоматического слияния с ветками, и вообще никак не затрагивает эти ветки

\begin{lstlisting}[
language = cmd,
numbers = none
]
git fetch origin
\end{lstlisting}


Отправить данные локальной ветки \texttt{master} на удаленный репозиторий \texttt{origin}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin master
\end{lstlisting}


Передать данные от локальной ветки \texttt{serverfix} в ветку \texttt{awesomebranch} на удаленном репозитории

\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin serverfix:awesomebranch
\end{lstlisting}

Вывести информацию о конкретном удаленном репозитории \texttt{origin}

\begin{lstlisting}[
numbers = none
]
git remote show origin
\end{lstlisting}


Изменить имя удаленного репозитория с \texttt{pb} на \texttt{paul}. Теперь к ветке \texttt{pb/master} нужно будет обращаться по имени \texttt{paul/master}

\begin{lstlisting}[
numbers = none
]
git remote rename pb paul
\end{lstlisting}


Удалить ссылку на удаленный репозиторий

\begin{lstlisting}[
numbers = none
]
git remote rm paul
\end{lstlisting}


\subsection{Работа с тегами}

Вывести список доступных тегов

\begin{lstlisting}[
language = cmd,
numbers = none
]
git tag
\end{lstlisting}


Вывести список тегов, отвечающих поисковому  шаблону

\begin{lstlisting}[
language = cmd,
numbers = none
]
git tag -l 'v1.8.*'
git tag -l 'v0.2*.*'
\end{lstlisting}


Создать тег с комментарием. Тег привязывается к последнему коммиту

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log -a v1.4 -m 'My version 1.4'
\end{lstlisting}

Вывести информацию по тегу

\begin{lstlisting}[
language = cmd,
numbers = none
]
git show v1.4
\end{lstlisting}


Создать легковесный тег (просто не указываются \texttt{-a}, \texttt{-s}, \texttt{-m})

\begin{lstlisting}[
language = cmd,
numbers = none
]
git tag v1.4-lw
\end{lstlisting}


Отправить все теги на удаленный репозиторий. По умолчанию команда \texttt{git push} не отправляет теги на удаленный репозиторий

\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin --tags
\end{lstlisting}


\subsection{Работа с ветками}

Вывести список существующих веток

\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch
\end{lstlisting}


Создать новую ветку

\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch testing
\end{lstlisting}

Переключиться на новую ветку

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout testing
\end{lstlisting}

Создать новую ветку и тут же переключитсья на нее

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout -b iss53
\end{lstlisting}


Внедрить внесенные изменения в готовый код

\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge hotfix
\end{lstlisting}

Удалить ветку 

\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch -d hotfix
\end{lstlisting}

Вывести ветки, НЕ объединенные с текущей веткой

\begin{lstlisting}[
language = cmd,
numbers = none
]
git branch --no-marged
\end{lstlisting}


Создать \emph{локальную копию ветки} \texttt{serverfix} на основе \emph{удаленной ветки} \texttt{origin/serverfix}. В результате будет получена локальная ветка, которая начинается там же, где и ветка \texttt{origin/serverfix}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout -b serverfix origin/serverfix
\end{lstlisting}

\noindent или альтернативный вариант

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout --track origin/serverfix
\end{lstlisting}

Создать локальную копию ветки с именем \texttt{sf} на основе удаленной ветки \texttt{origin/serverfix}. Теперь локальная ветка \texttt{sf} поддерживает автоматический обмен данными с удаленной веткой \texttt{origin/serverfix}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout -b sf origin/serverfix
\end{lstlisting}


Вывести только те коммиты, которых нет в ветке \texttt{master}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log master..contrib
\end{lstlisting}
или так
\begin{lstlisting}[
language = cmd,
numbers = none
]
git log contrib --not master
\end{lstlisting}
или так
\begin{lstlisting}[
language = cmd,
numbers = none
]
git log ^master contrib
\end{lstlisting}


Вывести только те наработки из \emph{тематической ветки}, которые появились там после расхождения с веткой \texttt{master}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git diff master...contrib
\end{lstlisting}

Вывести изменения, которые присутствуют только в ветке \texttt{master}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git diff origin/master..master
\end{lstlisting}

Для обращения к существующей ветке можно использовать краткую форму \texttt{@\{u\}}. К примеру, если мы следим из ветки \texttt{master} за веткой \texttt{origin/master}, то для краткости можно писать так

\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge @{u}
\end{lstlisting}
вместо
\begin{lstlisting}[
language = cmd,
numbers = none
]
git merge origin/master
\end{lstlisting}

Вывести список веток \emph{наблюдения}. Все цифры представляют собой показатели, зафиксированные в момент последнего скачивания данных с каждого сервера. Данная команда не обращается к серверам, а просто сообщает локальные данные из кэша. Для получения актуальной информации о количестве новых коммитов на локальных и удаленных ветках следует извлечь данные со всех удаленных серверов и только затем воспользоваться этой командой, т.е.
\begin{lstlisting}[
language = cmd,
numbers = none
]
git fetch --all
git branch -vv
 iss53 7e424c3 [origin/iss53: ahead 2] forgot the brackets
 master 1ae2a45 [origin/master] deploying index fix
 serverfix 5ea463a [teamone/server-fix-good: ahead 3, behind] this should do it
 ...
\end{lstlisting} 


\subsection{Отправка данных на удаленный репозиторий}

Для того чтобы отправить данные из локального репозитория на удаленный следует использовать конструкцию

\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin master
\end{lstlisting}

\noindent но предварительно необходимо слить данные из удаленного репозитория с помощью команды

\begin{lstlisting}[
language = cmd,
numbers = none
]
git pull origin master --allow-unrelated-histories
\end{lstlisting}


\subsection{Перемещение данных}

Изменения, зафиксированные в одной ветке, повторить в другой ветке (в \texttt{Git} это называется \emph{перемещением}). Например, чтобы повторить изменения из ветки \texttt{experiment} в ветке \texttt{master}, следует сначала перейти в ту ветку, из которой требуется перенести изменения (ветка \texttt{experiment}), а затем воспользоваться командой \texttt{git rebase}\footnote{Работает это следующим образом: ищется общий предок двух веток (текущей ветки и ветки, в которую выполняется перемещение), вычисляется разница, вносимая каждым коммитом текущей ветки, и сохраняется во временных файлах. После этого текущая ветка сопоставляется тому же коммиту, что и ветка, в которую осуществляется перемещение, и одно за другим происходят все изменения}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git checkout experiment
git rebase master
\end{lstlisting}


Внести изменения клиентской части (ветка \texttt{client}) в окончательную версию кода (ветка \texttt{master}), оставив изменения серверной части (ветка \texttt{server}) для дальнейшего тестирования. Другими словами, взять изменения клиентской части, не связанные с изменениями на серверной стороне, и воспроизвести их в ветке \texttt{master} можно следующим образом\footnote{По сути, команда приказывает <<перейти в ветку \texttt{client}, найти исправления от общего предка веток \texttt{client} и \texttt{server} и повторить их в ветке \texttt{master}>>}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase --onto master server client
\end{lstlisting}

Переместить изменения из ветки \texttt{server} в ветку \texttt{master}, вне зависимости от того, в какой ветке вы находитесь, позволяет команда \texttt{git rebase [main\_branch] [topic\_branch]}. Эта команда переключает на тематическую ветку (в данном случае -- на ветку \texttt{server}) и воспроизводит ее содержимое в основной ветке (\texttt{master})

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase master server
\end{lstlisting}

\remark{%
    При перемещении изменений из одной ветки в другую, нужно перейти на ту ветку, \emph{из которой} планируется переместить изменения
}

\subsection{Перемещение отдельного коммита}

Взять представленные в коммите изменения и попытаться применить их в текущей ветке. Команда извлечет изменения, появившиеся в коммите, но при этом измениться контрольная сумма SHA-1 коммита, так как у него другая дата применения

\begin{lstlisting}[
language = cmd,
numbers = none
]
git cherry-pick e43a6fd3e9488...
\end{lstlisting}


\subsection{Удаление коммитов}

Для того чтобы удалить послдений коммит следует сначала удалить коммит в локальном репозитории

\begin{lstlisting}[
language = cmd,
numbers = none
]
git rebase -i HEAD~2
\end{lstlisting}
а затем отправить данные в форсированном режиме на удаленный репоизторий

\begin{lstlisting}[
language = cmd,
numbers = none
]
git push origin +master --force
\end{lstlisting}


\remark{%
После удаления коммита или после изменения комментария коммита обязательно нужно <<залить>> обновления на удаленный сервер с помощью \lstinline{git push origin master --force}
}


\subsection{Просмотр информации по коммитам}

Если требуется вывести информацию по коммиту (например, требуется выяснить что было удалено/добавлено в этот коммит), то можно обратиться к коммиту через его хеш-код

\begin{lstlisting}[
language = cmd,
numbers = none
]
git show 06e6bbc
\end{lstlisting}

Информацию по последнему коммиту можно посмотреть следующим образом

\begin{lstlisting}[
language = cmd,
numbers = none
]
git show master
\end{lstlisting}

\subsection{Ссылки на предков}

Для просмотра \emph{предыдущего коммита} достаточно написать \texttt{HEAD\^}, что означает <<родитель HEAD>>

\begin{lstlisting}[
language = cmd,
numbers = none
]
git show HEAD^
\end{lstlisting}


Другое распространенное обозначение \emph{предка} -- символ \lstinline{~}. Он также соответствует \emph{ссылке на первого родителя}, поэтому записи \lstinline{HEAD^} и \lstinline{HEAD~} эквивалентны. А вот если указать номер после символа \lstinline{~}, то проявятся различия между \lstinline{~} и \lstinline{^}.

Например, запись \lstinline{HEAD~2} означает <<первый предок первого предка>>, при этом происходит переход от заданного предка вглубь указанное число раз, т.е. \lstinline{HEAD~3} укажет на четвертый\footnote{Так как отсчет ведется, начиная со второго коммита от конца ветки} от конца ветки коммит.

После символа \lstinline{^} можно указать число: например, запись \lstinline{d921970^2} означает <<второй предок коммита d921970>>. Этот синтаксис применяется \underline{только} в случае \emph{коммитов слияния}, у которых существует несколько предков. \emph{Первый родитель} -- это ветка, на которой вы находились в момент слияния, а \emph{второй родитель} -- коммит на ветке, которая подверглась слиянию

\begin{lstlisting}[
language = cmd,
numbers = none
]
git show d921970^2
\end{lstlisting}

Указанные обозначения можно комбинировать. К примеру, второго родителя четвертого от конца ветки коммита (при условии, что это коммит слияния) можно получить, написав \lstinline{HEAD~3^2}.

\subsection{Диапазоны коммитов}

Вывести все коммиты, достижимые по ссылке \texttt{refA} или \texttt{refB}, но не достижимые по ссылке \texttt{refC}

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log refA refB ^refC
git log refA refB --not refC
\end{lstlisting}

Вывести только те коммиты, которые есть либо в ветке \texttt{master}, либо в ветке \texttt{experiment}, но не в обеих ветках одновременно

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log master...experiment
\end{lstlisting}

С этой командой часто используют параметр \lstinline{--left-right}, позволяющий посмотреть, с какой стороны диапазона находится каждый коммит

\begin{lstlisting}[
language = cmd,
numbers = none
]
git log --left-right master...experiment
\end{lstlisting}

\subsection{Скрытие и очистка}

Часто во время работы над проектом, все еще находится в беспорядочном состоянии, возникает необходимость перейти в другую ветку и поработать над другим аспектом. Проблема в том, что фиксировать работу, сделанную наполовину, чтобы позже к ней вернуться вы не хотите. В такой ситуации на помощь приходит команда \texttt{git stash}.

Если, к примеру, вы отредактируете два файла и только один из них проиндексируете без фиксации результатов своей работы, то с помощью команды
\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash save
\end{lstlisting}
можно будет перейти на другую ветку, скрыв наработки в буфере.

Теперь можно легко менять ветки и работать над другими фрагментами проекта -- все изменения хранятся в стеке. Увидеть содержимое позволяет команда

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash list
\end{lstlisting}

Вернуть спрятанные в буфер изменения в рабочее состояние можно командой

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash apply
\end{lstlisting}

Если требуется вернуться к работе над версией, сохраненной в буфере ранее, следует указать ее номер

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash apply stash@{2}
\end{lstlisting}

\remark{%
Вообще говоря, нет необходимости возвращать содерижмое буфера в чистый рабочий каталог и в ту же ветку, из которой они были сохранены. Можно скрыть изменения одной ветки, перейти в другую и попытаться вставить изменнное состояние туда
}

После извлечения информации из буфера файлы, которые до помещения в буфер были проиндексированы, автоматически в это состояние не вернуться. Чтобы сразу вернуть данные из буфера в исходное состояние, нужно написать

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash apply --index
\end{lstlisting}

При этом команда \texttt{apply} только возвращает данные в ветке, но из стека они никуда не деваются. Убрать их из стека позволяет команда \texttt{git stash drop} с именем удаляемого файла

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash drop stash@{0}
\end{lstlisting}


Врочем, существует также команда
\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash pop
\end{lstlisting}
которая возвращает сохраненную в буфере информацию в ветку и немедленно удаляет ее из буфера.

\subsection{Более сложные варианты скрытия}

Чтобы не скрывать данные, которые были проиндексированы командой \texttt{git add}, следует написать

\begin{lstlisting}[
language = cmd,
numbers = none
]
git stash save --keep-index
\end{lstlisting}




\subsection{Принудительно перезаписать локальные файлы}

Если требуется локальные файлы перезаписать файлами с удаленного сервера, то алгоритм следующий

\begin{lstlisting}[
language = cmd,
numbers = none
]
git fetch --all
get reset --hard origin/master
\end{lstlisting}

Команда \lstinline{git fetch --all} скачивает отсутствующие файлы с удаленного репозитория без попытки слить или переместить данные, а \lstinline{git reset --hard origin/master} <<сбрасывает>> ветку \texttt{master}. Опция \lstinline{--hard} изменяет все файлы в рабочем дереве таким образом, чтобы они совпадали с файлами из \texttt{master/origin}.


% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{  }{  }
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\end{document}
